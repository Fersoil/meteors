
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../quickstart/">
      
      
        <link rel="next" href="../changelog/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>API Reference üìñ - Meteors</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.35f28582.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Meteors" class="md-header__button md-logo" aria-label="Meteors" data-md-component="logo">
      
  <img src="../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Meteors
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API Reference üìñ
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Meteors" class="md-nav__button md-logo" aria-label="Meteors" data-md-component="logo">
      
  <img src="../assets/logo.png" alt="logo">

    </a>
    Meteors
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home üè†
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../quickstart/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Quickstart üöÄ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    API Reference üìñ
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    API Reference üìñ
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#meteors" class="md-nav__link">
    <span class="md-ellipsis">
      Meteors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Meteors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime" class="md-nav__link">
    <span class="md-ellipsis">
      lime
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.Explainer" class="md-nav__link">
    <span class="md-ellipsis">
      Explainer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Explainer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Explainer.device" class="md-nav__link">
    <span class="md-ellipsis">
      device
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Explainer.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.validate_hsi_attributions" class="md-nav__link">
    <span class="md-ellipsis">
      validate_hsi_attributions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpatialAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpatialAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpatialAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpatialAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpatialAttributes.segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      segmentation_mask
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpectralAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpectralAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpectralAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpectralAttributes.band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpectralAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_segmentation_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.adjust_and_validate_segment_ranges" class="md-nav__link">
    <span class="md-ellipsis">
      adjust_and_validate_segment_ranges
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.align_band_names_with_mask" class="md-nav__link">
    <span class="md-ellipsis">
      align_band_names_with_mask
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.ensure_torch_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_torch_tensor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.resolve_inference_device" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_inference_device
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_and_convert_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      validate_and_convert_attributes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_and_convert_mask" class="md-nav__link">
    <span class="md-ellipsis">
      validate_and_convert_mask
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_band_format" class="md-nav__link">
    <span class="md-ellipsis">
      validate_band_format
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_band_names" class="md-nav__link">
    <span class="md-ellipsis">
      validate_band_names
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_segment_format" class="md-nav__link">
    <span class="md-ellipsis">
      validate_segment_format
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_segment_range" class="md-nav__link">
    <span class="md-ellipsis">
      validate_segment_range
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_shapes" class="md-nav__link">
    <span class="md-ellipsis">
      validate_shapes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      validate_tensor
    </span>
  </a>
  
    <nav class="md-nav" aria-label="validate_tensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lime-base" class="md-nav__link">
    <span class="md-ellipsis">
      Lime Base
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hyperspectral-image" class="md-nav__link">
    <span class="md-ellipsis">
      HyperSpectral Image
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi" class="md-nav__link">
    <span class="md-ellipsis">
      hsi
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI" class="md-nav__link">
    <span class="md-ellipsis">
      HSI
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spatial_mask" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spectral_axis" class="md-nav__link">
    <span class="md-ellipsis">
      spectral_axis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.extract_band_by_name" class="md-nav__link">
    <span class="md-ellipsis">
      extract_band_by_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_rgb_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_rgb_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.validate_image_data" class="md-nav__link">
    <span class="md-ellipsis">
      validate_image_data
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.ensure_image_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_image_tensor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.ensure_wavelengths_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_wavelengths_tensor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.get_channel_axis" class="md-nav__link">
    <span class="md-ellipsis">
      get_channel_axis
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.process_and_validate_binary_mask" class="md-nav__link">
    <span class="md-ellipsis">
      process_and_validate_binary_mask
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.resolve_inference_device" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_inference_device
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.validate_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      validate_orientation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.validate_shapes" class="md-nav__link">
    <span class="md-ellipsis">
      validate_shapes
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Changelog üìù
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../how-to-guides/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    How-To Guides üìö
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#meteors" class="md-nav__link">
    <span class="md-ellipsis">
      Meteors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Meteors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime" class="md-nav__link">
    <span class="md-ellipsis">
      lime
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.Explainer" class="md-nav__link">
    <span class="md-ellipsis">
      Explainer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Explainer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Explainer.device" class="md-nav__link">
    <span class="md-ellipsis">
      device
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Explainer.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSIAttributes.validate_hsi_attributions" class="md-nav__link">
    <span class="md-ellipsis">
      validate_hsi_attributions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpatialAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpatialAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpatialAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpatialAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpatialAttributes.segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      segmentation_mask
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpectralAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpectralAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpectralAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpectralAttributes.band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.HSISpectralAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_segmentation_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.lime.Lime.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.adjust_and_validate_segment_ranges" class="md-nav__link">
    <span class="md-ellipsis">
      adjust_and_validate_segment_ranges
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.align_band_names_with_mask" class="md-nav__link">
    <span class="md-ellipsis">
      align_band_names_with_mask
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.ensure_torch_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_torch_tensor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.resolve_inference_device" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_inference_device
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_and_convert_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      validate_and_convert_attributes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_and_convert_mask" class="md-nav__link">
    <span class="md-ellipsis">
      validate_and_convert_mask
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_band_format" class="md-nav__link">
    <span class="md-ellipsis">
      validate_band_format
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_band_names" class="md-nav__link">
    <span class="md-ellipsis">
      validate_band_names
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_segment_format" class="md-nav__link">
    <span class="md-ellipsis">
      validate_segment_format
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_segment_range" class="md-nav__link">
    <span class="md-ellipsis">
      validate_segment_range
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_shapes" class="md-nav__link">
    <span class="md-ellipsis">
      validate_shapes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.lime.validate_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      validate_tensor
    </span>
  </a>
  
    <nav class="md-nav" aria-label="validate_tensor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lime-base" class="md-nav__link">
    <span class="md-ellipsis">
      Lime Base
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hyperspectral-image" class="md-nav__link">
    <span class="md-ellipsis">
      HyperSpectral Image
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi" class="md-nav__link">
    <span class="md-ellipsis">
      hsi
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI" class="md-nav__link">
    <span class="md-ellipsis">
      HSI
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spatial_mask" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spectral_axis" class="md-nav__link">
    <span class="md-ellipsis">
      spectral_axis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.extract_band_by_name" class="md-nav__link">
    <span class="md-ellipsis">
      extract_band_by_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_rgb_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_rgb_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.validate_image_data" class="md-nav__link">
    <span class="md-ellipsis">
      validate_image_data
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.ensure_image_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_image_tensor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.ensure_wavelengths_tensor" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_wavelengths_tensor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.get_channel_axis" class="md-nav__link">
    <span class="md-ellipsis">
      get_channel_axis
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.process_and_validate_binary_mask" class="md-nav__link">
    <span class="md-ellipsis">
      process_and_validate_binary_mask
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.resolve_inference_device" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_inference_device
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.validate_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      validate_orientation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.meteors.hsi.validate_shapes" class="md-nav__link">
    <span class="md-ellipsis">
      validate_shapes
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="api-reference">API Reference</h1>
<p>Structure:</p>
<ul>
<li><a href="#api-reference">API Reference</a></li>
<li><a href="#meteors">Meteors</a><ul>
<li><a href="#lime">Lime</a></li>
<li><a href="#lime-base">Lime Base</a></li>
<li><a href="#hsi">HyperSpectral Image</a></li>
</ul>
</li>
</ul>
<h2 id="meteors">Meteors</h2>
<h3 id="lime">Lime</h3>


<div class="doc doc-object doc-module">



<a id="src.meteors.lime"></a>
    <div class="doc doc-contents first">



  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="src.meteors.lime.Explainer" class="doc doc-heading">
            <code>Explainer</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="abc.ABC">ABC</span></code></p>


        <p>Explainer class for explaining models.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>explainable_model</code></td>
            <td>
                  <code><span title="meteors.utils.models.ExplainableModel">ExplainableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>interpretable_model</code></td>
            <td>
                  <code><span title="meteors.utils.models.InterpretableModel">InterpretableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The interpretable model used to approximate the black-box model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Current supported interpretable models are <code>LinearModel</code>, <code>SkLearnLinearModel</code>,
    <code>SkLearnLasso</code> and <code>SkLearnRidge</code>.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/meteors/lime.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Explainer</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Explainer class for explaining models.</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel): The explainable model to be explained.</span>
<span class="sd">        interpretable_model (InterpretableModel): The interpretable model used to approximate the black-box model</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Current supported interpretable models are `LinearModel`, `SkLearnLinearModel`,</span>
<span class="sd">            `SkLearnLasso` and `SkLearnRidge`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">,</span> <span class="n">interpretable_model</span><span class="p">:</span> <span class="n">InterpretableModel</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span> <span class="o">=</span> <span class="n">explainable_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpretable_model</span> <span class="o">=</span> <span class="n">interpretable_model</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the device on which the explainable model is located.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.device: The device on which the explainable model is located.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="o">.</span><span class="n">parameters</span><span class="p">())</span><span class="o">.</span><span class="n">device</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Could not extract device from the explainable model, setting device to cpu&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Not a torch model, setting device to cpu&quot;</span><span class="p">)</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">device</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move the explainable model to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str or torch.device): The device to move the explainable model to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated Explainer instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.lime.Explainer.device" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-cached"><code>cached</code></small>
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the device on which the explainable model is located.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.device: The device on which the explainable model is located.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.Explainer.to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Move the explainable model to the specified device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str or <span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to move the explainable model to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated Explainer instance.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move the explainable model to the specified device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str or torch.device): The device to move the explainable model to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated Explainer instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="src.meteors.lime.HSIAttributes" class="doc doc-heading">
            <code>HSIAttributes</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="pydantic.BaseModel">BaseModel</span></code></p>


        <p>Represents an object that contains hsi attributes and explanations.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSIAttributes.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral image object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSIAttributes.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSIAttributes.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>R^2 score of interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSIAttributes.mask">mask</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><code>superpixel</code> or <code>superband</code> mask used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSIAttributes.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSIAttributes.model_config">model_config</span></code></td>
            <td>
                  <code><span title="pydantic.ConfigDict">ConfigDict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Configuration dictionary for the model.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/lime.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSIAttributes</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an object that contains hsi attributes and explanations.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral image object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): R^2 score of interpretable model used for the explanation.</span>
<span class="sd">        mask (torch.Tensor | None): `superpixel` or `superband` mask used for the explanation.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        model_config (ConfigDict): Configuration dictionary for the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hsi</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">HSI</span><span class="p">,</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Hyperspectral image object for which the explanations were created.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">validate_and_convert_attributes</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Attributions (explanations) for the hsi.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">score</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">float</span><span class="p">,</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">le</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;R^2 score of interpretable model used for the explanation.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">validate_and_convert_mask</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;`superpixel` or `superband` mask used for the explanation.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">resolve_inference_device</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Device to be used for inference. If None, the device of the input hsi will be used. &quot;</span>
                <span class="s2">&quot;Defaults to None.&quot;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes.</span>

<span class="sd">        This method should be implemented in the subclass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method should be implemented in the subclass&quot;</span><span class="p">)</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span><span class="n">arbitrary_types_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_hsi_attributions_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions with mask and performs necessary operations to ensure compatibility with the</span>
<span class="sd">        device.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the shapes of the attributes and hsi tensors do not match.</span>
<span class="sd">            ValueError: If the mask is provided and its shape does not match the hsi.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_hsi_attributions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions.</span>

<span class="sd">        This method performs validation on the hsi attributions to ensure they are correct.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The current instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move the hsi and attributes tensors to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str or torch.device): The device to move the tensors to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The modified object with tensors moved to the specified device.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSIAttributes(hsi, attributes, score=0.5)</span>
<span class="sd">            &gt;&gt;&gt; attrs.to(&quot;cpu&quot;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.to(&quot;cuda&quot;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">            device(type=&#39;cuda&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">            device(type=&#39;cuda&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the image data along with the attributions to the target orientation.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_orientation (tuple[str, str, str] | list[str] | str): The target orientation for the attribution data.</span>
<span class="sd">                This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">            inplace (bool, optional): Whether to modify the data in place or return a new object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated Image object with the new orientation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span>

        <span class="k">if</span> <span class="n">current_orientation</span> <span class="o">!=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
            <span class="n">new_orientation</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
                <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
                    <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">attrs</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.lime.HSIAttributes.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes.</p>
<p>This method should be implemented in the subclass.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.HSIAttributes.change_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Changes the orientation of the image data along with the attributions to the target orientation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>target_orientation</code></td>
            <td>
                  <code>tuple[str, str, str] | list[str] | str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The target orientation for the attribution data.
This should be a tuple of three one-letter strings in any order: "C", "H", "W".</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>inplace</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to modify the data in place or return a new object.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated Image object with the new orientation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the target orientation is not a valid tuple of three one-letter strings.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the image data along with the attributions to the target orientation.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_orientation (tuple[str, str, str] | list[str] | str): The target orientation for the attribution data.</span>
<span class="sd">            This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">        inplace (bool, optional): Whether to modify the data in place or return a new object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated Image object with the new orientation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span>
    <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span>

    <span class="k">if</span> <span class="n">current_orientation</span> <span class="o">!=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
        <span class="n">new_orientation</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
            <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
                <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">attrs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.HSIAttributes.to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Move the hsi and attributes tensors to the specified device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str or <span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to move the tensors to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The modified object with tensors moved to the specified device.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move the hsi and attributes tensors to the specified device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str or torch.device): The device to move the tensors to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The modified object with tensors moved to the specified device.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; attrs = HSIAttributes(hsi, attributes, score=0.5)</span>
<span class="sd">        &gt;&gt;&gt; attrs.to(&quot;cpu&quot;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.to(&quot;cuda&quot;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">        device(type=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">        device(type=&#39;cuda&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.HSIAttributes.validate_hsi_attributions" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_hsi_attributions</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Validates the hsi attributions.</p>
<p>This method performs validation on the hsi attributions to ensure they are correct.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The current instance of the class.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">validate_hsi_attributions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions.</span>

<span class="sd">    This method performs validation on the hsi attributions to ensure they are correct.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The current instance of the class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="src.meteors.lime.HSISpatialAttributes" class="doc doc-heading">
            <code>HSISpatialAttributes</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.meteors.lime.HSIAttributes" href="#src.meteors.lime.HSIAttributes">HSIAttributes</a></code></p>


        <p>Represents spatial attributes of an hsi used for explanation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpatialAttributes.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral image object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpatialAttributes.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpatialAttributes.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>R^2 score of interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpatialAttributes.mask">mask</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Original Spatial (Segmentation) mask used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpatialAttributes.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpatialAttributes.model_config">model_config</span></code></td>
            <td>
                  <code><span title="pydantic.ConfigDict">ConfigDict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Configuration dictionary for the model.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.lime.HSISpatialAttributes.segmentation_mask" href="#src.meteors.lime.HSISpatialAttributes.segmentation_mask">segmentation_mask</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Spatial (Segmentation) mask used for the explanation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/lime.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSISpatialAttributes</span><span class="p">(</span><span class="n">HSIAttributes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents spatial attributes of an hsi used for explanation.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral image object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): R^2 score of interpretable model used for the explanation.</span>
<span class="sd">        mask (torch.Tensor | None): Original Spatial (Segmentation) mask used for the explanation.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        model_config (ConfigDict): Configuration dictionary for the model.</span>
<span class="sd">        segmentation_mask (torch.Tensor): Spatial (Segmentation) mask used for the explanation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segmentation_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the spatial segmentation mask.</span>

<span class="sd">        This method selects the segmentation mask in 2D format if it has 2 dimensions,</span>
<span class="sd">        if its dimension matches the hsi, it selects the first index along the spectral axis.</span>
<span class="sd">        else, it raises a ValueError.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The spatial segmentation mask.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the segmentation mask is not provided.</span>
<span class="sd">            ValueError: If the segmentation mask has an unsupported number of dimensions.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = torch.zeros((3, 2, 2))</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSISpatialAttributes(hsi, attributes, score=0.5, segmentation_mask=segmentation_mask)</span>
<span class="sd">            &gt;&gt;&gt; attrs.spatial_segmentation_mask</span>
<span class="sd">            tensor([[0., 0.],</span>
<span class="sd">                    [0., 0.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Segmentation mask is not provided&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes.</span>

<span class="sd">        In the case of spatial attributes, the flattened attributes are 2D spatial attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = torch.zeros((3, 2, 2))</span>
<span class="sd">        &gt;&gt;&gt; attrs = HSISpatialAttributes(hsi, attributes, score=0.5, segmentation_mask=segmentation_mask)</span>
<span class="sd">        &gt;&gt;&gt; attrs.flattened_attributes</span>
<span class="sd">            tensor([[0., 0.],</span>
<span class="sd">                    [0., 0.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.lime.HSISpatialAttributes.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes.</p>
<p>In the case of spatial attributes, the flattened attributes are 2D spatial attributes.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <blockquote>
<blockquote>
<blockquote>
<p>segmentation_mask = torch.zeros((3, 2, 2))
attrs = HSISpatialAttributes(hsi, attributes, score=0.5, segmentation_mask=segmentation_mask)
attrs.flattened_attributes
    tensor([[0., 0.],
            [0., 0.]])</p>
</blockquote>
</blockquote>
</blockquote>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.lime.HSISpatialAttributes.segmentation_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the spatial segmentation mask.</p>
<p>This method selects the segmentation mask in 2D format if it has 2 dimensions,
if its dimension matches the hsi, it selects the first index along the spectral axis.
else, it raises a ValueError.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The spatial segmentation mask.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the segmentation mask is not provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the segmentation mask has an unsupported number of dimensions.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSISpatialAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">spatial_segmentation_mask</span>
<span class="go">tensor([[0., 0.],</span>
<span class="go">        [0., 0.]])</span>
</code></pre></div>
    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="src.meteors.lime.HSISpectralAttributes" class="doc doc-heading">
            <code>HSISpectralAttributes</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.meteors.lime.HSIAttributes" href="#src.meteors.lime.HSIAttributes">HSIAttributes</a></code></p>


        <p>Represents an hsi with spectral attributes used for explanation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpectralAttributes.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral image object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpectralAttributes.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpectralAttributes.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>R^2 score of interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpectralAttributes.mask">mask</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Original Band mask used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpectralAttributes.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpectralAttributes.model_config">model_config</span></code></td>
            <td>
                  <code><span title="pydantic.ConfigDict">ConfigDict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Configuration dictionary for the model.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.lime.HSISpectralAttributes.band_names">band_names</span></code></td>
            <td>
                  <code>dict[str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary that translates the band names into the band segment ids.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/lime.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSISpectralAttributes</span><span class="p">(</span><span class="n">HSIAttributes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an hsi with spectral attributes used for explanation.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral image object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): R^2 score of interpretable model used for the explanation.</span>
<span class="sd">        mask (torch.Tensor | None): Original Band mask used for the explanation.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        model_config (ConfigDict): Configuration dictionary for the model.</span>
<span class="sd">        band_names (dict[str, int]): Dictionary that translates the band names into the band segment ids.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">band_names</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Dictionary that translates the band names into the band segment ids.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">band_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a band mask.</span>

<span class="sd">        The method selects the appropriate dimensions from the `band_mask` tensor</span>
<span class="sd">        based on the `axis_to_select` and returns a flattened version of the selected</span>
<span class="sd">        tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The flattened band mask tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the band mask is not provided.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; band_names = {&quot;R&quot;: 0, &quot;G&quot;: 1, &quot;B&quot;: 2}</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSISpectralAttributes(hsi, attributes, score=0.5, band_mask=band_mask)</span>
<span class="sd">            &gt;&gt;&gt; attrs.spectral_band_mask</span>
<span class="sd">            torch.tensor([0, 1, 2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Band mask is not provided&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes.</span>

<span class="sd">        In the case of spectral attributes, the flattened attributes are 1D spectral attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.lime.HSISpectralAttributes.band_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">band_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a band mask.</p>
<p>The method selects the appropriate dimensions from the <code>band_mask</code> tensor
based on the <code>axis_to_select</code> and returns a flattened version of the selected
tensor.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The flattened band mask tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the band mask is not provided.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSISpectralAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">spectral_band_mask</span>
<span class="go">torch.tensor([0, 1, 2])</span>
</code></pre></div>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.lime.HSISpectralAttributes.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes.</p>
<p>In the case of spectral attributes, the flattened attributes are 1D spectral attributes.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="src.meteors.lime.Lime" class="doc doc-heading">
            <code>Lime</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.meteors.lime.Explainer" href="#src.meteors.lime.Explainer">Explainer</a></code></p>


        <p>Lime class is a subclass of Explainer and represents the Lime explainer. Lime is an interpretable model-agnostic
explanation method that explains the predictions of a black-box model by approximating it with a simpler
interpretable model.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>explainable_model</code></td>
            <td>
                  <code><span title="meteors.utils.models.ExplainableModel">ExplainableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>interpretable_model</code></td>
            <td>
                  <code><span title="meteors.utils.models.InterpretableModel">InterpretableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The interpretable model used to approximate the black-box model.
Defaults to <code>SkLearnLasso</code> with alpha parameter set to 0.08.</p>
              </div>
            </td>
            <td>
                  <code><span title="meteors.utils.models.SkLearnLasso">SkLearnLasso</span>(alpha=0.08)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>similarity_func</code></td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The similarity function used by Lime.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>perturb_func</code></td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The perturbation function used by Lime.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/lime.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span>
<span class="normal">1507</span>
<span class="normal">1508</span>
<span class="normal">1509</span>
<span class="normal">1510</span>
<span class="normal">1511</span>
<span class="normal">1512</span>
<span class="normal">1513</span>
<span class="normal">1514</span>
<span class="normal">1515</span>
<span class="normal">1516</span>
<span class="normal">1517</span>
<span class="normal">1518</span>
<span class="normal">1519</span>
<span class="normal">1520</span>
<span class="normal">1521</span>
<span class="normal">1522</span>
<span class="normal">1523</span>
<span class="normal">1524</span>
<span class="normal">1525</span>
<span class="normal">1526</span>
<span class="normal">1527</span>
<span class="normal">1528</span>
<span class="normal">1529</span>
<span class="normal">1530</span>
<span class="normal">1531</span>
<span class="normal">1532</span>
<span class="normal">1533</span>
<span class="normal">1534</span>
<span class="normal">1535</span>
<span class="normal">1536</span>
<span class="normal">1537</span>
<span class="normal">1538</span>
<span class="normal">1539</span>
<span class="normal">1540</span>
<span class="normal">1541</span>
<span class="normal">1542</span>
<span class="normal">1543</span>
<span class="normal">1544</span>
<span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span>
<span class="normal">1551</span>
<span class="normal">1552</span>
<span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span>
<span class="normal">1580</span>
<span class="normal">1581</span>
<span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span>
<span class="normal">1605</span>
<span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span>
<span class="normal">1653</span>
<span class="normal">1654</span>
<span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span>
<span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span>
<span class="normal">1732</span>
<span class="normal">1733</span>
<span class="normal">1734</span>
<span class="normal">1735</span>
<span class="normal">1736</span>
<span class="normal">1737</span>
<span class="normal">1738</span>
<span class="normal">1739</span>
<span class="normal">1740</span>
<span class="normal">1741</span>
<span class="normal">1742</span>
<span class="normal">1743</span>
<span class="normal">1744</span>
<span class="normal">1745</span>
<span class="normal">1746</span>
<span class="normal">1747</span>
<span class="normal">1748</span>
<span class="normal">1749</span>
<span class="normal">1750</span>
<span class="normal">1751</span>
<span class="normal">1752</span>
<span class="normal">1753</span>
<span class="normal">1754</span>
<span class="normal">1755</span>
<span class="normal">1756</span>
<span class="normal">1757</span>
<span class="normal">1758</span>
<span class="normal">1759</span>
<span class="normal">1760</span>
<span class="normal">1761</span>
<span class="normal">1762</span>
<span class="normal">1763</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Lime</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lime class is a subclass of Explainer and represents the Lime explainer. Lime is an interpretable model-agnostic</span>
<span class="sd">    explanation method that explains the predictions of a black-box model by approximating it with a simpler</span>
<span class="sd">    interpretable model.</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel): The explainable model to be explained.</span>
<span class="sd">        interpretable_model (InterpretableModel): The interpretable model used to approximate the black-box model.</span>
<span class="sd">            Defaults to `SkLearnLasso` with alpha parameter set to 0.08.</span>
<span class="sd">        similarity_func (Callable[[torch.Tensor], torch.Tensor] | None, optional): The similarity function used by Lime.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        perturb_func (Callable[[torch.Tensor], torch.Tensor] | None, optional): The perturbation function used by Lime.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">,</span>
        <span class="n">interpretable_model</span><span class="p">:</span> <span class="n">InterpretableModel</span> <span class="o">=</span> <span class="n">SkLearnLasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.08</span><span class="p">),</span>
        <span class="n">similarity_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">,</span> <span class="n">interpretable_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_lime</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">,</span> <span class="n">interpretable_model</span><span class="p">,</span> <span class="n">similarity_func</span><span class="p">,</span> <span class="n">perturb_func</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_lime</span><span class="p">(</span>
        <span class="n">forward_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">interpretable_model</span><span class="p">:</span> <span class="n">InterpretableModel</span><span class="p">,</span>
        <span class="n">similarity_func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LimeBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the LimeBase object.</span>

<span class="sd">        Args:</span>
<span class="sd">            forward_func (Callable[[torch.Tensor], torch.Tensor]): The forward function of the explainable model.</span>
<span class="sd">            interpretable_model (InterpretableModel): The interpretable model used to approximate the black-box model.</span>
<span class="sd">            similarity_func (Callable | None): The similarity function used by Lime.</span>
<span class="sd">            perturb_func (Callable[[torch.Tensor], torch.Tensor] | None): The perturbation function used by Lime.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LimeBase: The constructed LimeBase object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LimeBase</span><span class="p">(</span>
            <span class="n">forward_func</span><span class="o">=</span><span class="n">forward_func</span><span class="p">,</span>
            <span class="n">interpretable_model</span><span class="o">=</span><span class="n">interpretable_model</span><span class="p">,</span>
            <span class="n">similarity_func</span><span class="o">=</span><span class="n">similarity_func</span><span class="p">,</span>
            <span class="n">perturb_func</span><span class="o">=</span><span class="n">perturb_func</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_segmentation_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;slic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a segmentation mask for the given hsi using the specified segmentation method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi for which the segmentation mask needs to be generated.</span>
<span class="sd">            segmentation_method (Literal[&quot;patch&quot;, &quot;slic&quot;], optional): The segmentation method to be used.</span>
<span class="sd">                Defaults to &quot;slic&quot;.</span>
<span class="sd">            **segmentation_method_params (Any): Additional parameters specific to the chosen segmentation method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The segmentation mask as a tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">            ValueError: If an unsupported segmentation method is specified.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((3, 240, 240)), wavelengths=[462.08, 465.27, 468.47])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;slic&quot;)</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;patch&quot;, patch_size=2)</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask[0, :2, :2]</span>
<span class="sd">            torch.tensor([[1, 1],</span>
<span class="sd">                          [1, 1]])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask[0, 2:4, :2]</span>
<span class="sd">            torch.tensor([[2, 2],</span>
<span class="sd">                          [2, 2]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image should be an instance of Image class&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;slic&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_slick_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported segmentation method: </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_indices</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a band mask based on the provided hsi and band information.</span>

<span class="sd">        Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.</span>
<span class="sd">        If you provide more than one, the band mask will be created using only one using the following priority:</span>
<span class="sd">        band_names &gt; band_wavelengths &gt; band_indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            band_names (None | list[str | list[str]] | dict[tuple[str, ...] | str, int], optional):</span>
<span class="sd">                The names of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            band_indices (None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]], optional):</span>
<span class="sd">                The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            band_wavelengths (None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float], optional):</span>
<span class="sd">                The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            device (str | torch.device | None, optional):</span>
<span class="sd">                The device to use for computation. Defaults to None.</span>
<span class="sd">            repeat_dimensions (bool, optional):</span>
<span class="sd">                Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</span>
<span class="sd">            mapping band names to segment IDs.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">            ValueError: If no band names, indices, or wavelengths are provided.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((len(wavelengths), 10, 10)), wavelengths=wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;]</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_names=band_names)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="sd">            &gt;&gt;&gt; band_indices = {&quot;RGB&quot;: [0, 1, 2]}</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_indices=band_indices)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;RGB&quot;: 1}</span>
<span class="sd">            &gt;&gt;&gt; band_wavelengths = {&quot;RGB&quot;: [(462.08, 465.27), (465.27, 468.47), (468.47, 471.68)]}</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_wavelengths=band_wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;RGB&quot;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;No band names, indices, or wavelengths are provided.&quot;</span>

        <span class="c1"># validate types</span>
        <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band names of spectral bands&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Only the band names will be used to create the band mask&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>
                <span class="n">band_groups</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_names</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect band names provided: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">elif</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of wavelengths&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Only the band wavelengths will be used to create the band mask&quot;</span><span class="p">)</span>
            <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span>
                    <span class="n">band_wavelengths</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges wavelengths provided, please check if provided wavelengths are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">elif</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of indices&quot;</span><span class="p">)</span>
            <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_indices</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_indices&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_input_band_indices</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_indices</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges indices provided, please check if provided indices are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_tensor_band_mask</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span>
            <span class="n">band_groups</span><span class="p">,</span>
            <span class="n">dict_labels_to_segment_ids</span><span class="o">=</span><span class="n">dict_labels_to_segment_ids</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">repeat_dimensions</span><span class="o">=</span><span class="n">repeat_dimensions</span><span class="p">,</span>
            <span class="n">return_dict_labels_to_segment_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_band_names_indexable</span><span class="p">(</span><span class="n">segment_name</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a list of strings into a tuple of strings if necessary to make it indexable.</span>

<span class="sd">        Args:</span>
<span class="sd">            segment_name (list[str] | tuple[str, ...] | str): The segment name to be converted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, ...] | str: The converted segment name.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the segment_name is not of type list or string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">segment_name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segment_name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect segment </span><span class="si">{</span><span class="n">segment_name</span><span class="si">}</span><span class="s2"> type. Should be either a list or string&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="c1"># @lru_cache(maxsize=32) Can&#39;t use with lists as they are not hashable</span>
    <span class="k">def</span> <span class="nf">_extract_bands_from_spyndex</span><span class="p">(</span><span class="n">segment_name</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts bands from the given segment name.</span>

<span class="sd">        Args:</span>
<span class="sd">            segment_name (list[str] | tuple[str, ...] | str): The name of the segment.</span>
<span class="sd">                Users may pass either band names or indices names, as in the spyndex library.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, ...] | str: A tuple of band names if multiple bands are extracted,</span>
<span class="sd">                or a single band name if only one band is extracted.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the provided band name is invalid.</span>
<span class="sd">                The band name must be either in `spyndex.indices` or `spyndex.bands`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">segment_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment_name</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">segment_name</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segment_name</span><span class="p">)</span>

        <span class="n">band_names_segment</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="n">band_names_segment</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spyndex</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
                <span class="n">band_names_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid band name </span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">, band name must be either in `spyndex.indices` or `spyndex.bands`&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">band_names_segment</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">band_names_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_indices_from_wavelength_indices_range</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts wavelength indices ranges to list indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[tuple[int, int]] | tuple[int, int]): The wavelength indices ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: The indices of bands corresponding to the wavelength indices ranges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validated_ranges_list</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="n">validated_ranges_list</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">validated_ranges_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">validated_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">validated_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="k">for</span> <span class="n">validated_range</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts band wavelengths indices from the given band names.</span>

<span class="sd">        This function takes a list or dictionary of band names or segments and extracts the list of wavelengths indices</span>
<span class="sd">        associated with each segment. It returns a tuple containing a dictionary with mapping segment labels into</span>
<span class="sd">        wavelength indices and a dictionary mapping segment labels into segment ids.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_names (list[str | list[str]] | dict[tuple[str, ...] | str, int]):</span>
<span class="sd">                A list or dictionary with band names or segments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[dict[tuple[str, ...] | str, list[int]], dict[tuple[str, ...] | str, int]]:</span>
<span class="sd">                A tuple containing the dictionary with mapping segment labels into wavelength indices and the mapping</span>
<span class="sd">                from segment labels into segment ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;band_names is a list of segments, creating a dictionary of segments&quot;</span><span class="p">)</span>
            <span class="n">band_names_hashed</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lime</span><span class="o">.</span><span class="n">_make_band_names_indexable</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">band_names</span><span class="p">]</span>
            <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">segment</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_names_hashed</span><span class="p">)}</span>
            <span class="n">segments_list</span> <span class="o">=</span> <span class="n">band_names_hashed</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">band_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">segments_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect band_names type. It should be a dict or a list&quot;</span><span class="p">)</span>
        <span class="n">segments_list_after_mapping</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lime</span><span class="o">.</span><span class="n">_extract_bands_from_spyndex</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments_list</span><span class="p">]</span>
        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">original_segment</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segments_list</span><span class="p">,</span> <span class="n">segments_list_after_mapping</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">segment_indices_ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">:</span>
                    <span class="n">segment_indices_ranges</span> <span class="o">+=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_to_indices</span><span class="p">(</span>
                        <span class="n">wavelengths</span><span class="p">,</span> <span class="p">(</span><span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">max_wavelength</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">segment_list</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_indices_ranges</span><span class="p">)</span>
                <span class="n">band_indices</span><span class="p">[</span><span class="n">original_segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment_list</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with segment </span><span class="si">{</span><span class="n">original_segment</span><span class="si">}</span><span class="s2"> and bands </span><span class="si">{</span><span class="n">segment</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">return</span> <span class="n">band_indices</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_wavelengths_to_indices</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts wavelength ranges to index ranges.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[tuple[float, float]] | tuple[float, float]): The wavelength ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[int, int]]: The index ranges corresponding to the wavelength ranges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">ranges</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_idx</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">end_idx</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the ranges or list of wavelengths into indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_wavelengths (dict): A dictionary mapping segment labels to wavelength list or ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary mapping segment labels to index ranges.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If band_wavelengths is not a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;band_wavelengths should be a dictionary&quot;</span><span class="p">)</span>

        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">band_wavelengths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch_dtype_to_python_dtype</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                    <span class="n">segment</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtype</span><span class="p">(</span><span class="n">segment</span><span class="p">)]</span>  <span class="c1"># type: ignore</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">):</span>
                    <span class="n">segment_dtype</span> <span class="o">=</span> <span class="n">change_dtype_of_list</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_list_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_dtype</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">segment_dtype</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="nb">tuple</span><span class="p">(</span><span class="n">change_dtype_of_list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ranges</span><span class="p">),</span> <span class="n">dtype</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
                            <span class="k">for</span> <span class="n">ranges</span> <span class="ow">in</span> <span class="n">segment</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">segment_dtype</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">change_dtype_of_list</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>

                    <span class="n">valid_segment_range</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">segment_dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">range_indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_segment_range</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                    <span class="n">valid_indices_format</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">range_indices</span><span class="p">)</span>
                    <span class="n">valid_range_indices</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_indices_format</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_range_indices</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="n">band_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="k">return</span> <span class="n">band_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_wavelengths_list_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a list of wavelengths into indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[float]): The list of wavelengths.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: The indices corresponding to the wavelengths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wavelength</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">wavelengths</span> <span class="o">==</span> <span class="n">wavelength</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">as_tuple</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">number_of_elements</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">numel</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_of_elements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">number_of_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t find wavelength of value </span><span class="si">{</span><span class="n">wavelength</span><span class="si">}</span><span class="s2"> in list of wavelength&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wavelength of value </span><span class="si">{</span><span class="n">wavelength</span><span class="si">}</span><span class="s2"> was present more than once in list of wavelength&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_indices_from_input_band_indices</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">input_band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get band indices from band list or ranges indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_indices (dict[str | tuple[str, ...], ListOfWavelengthsIndices]):</span>
<span class="sd">                A dictionary mapping segment labels to a list of wavelength indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str | tuple[str, ...], list[int]]: A dictionary mapping segment labels to a list of band indices.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `band_indices` is not a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_band_indices</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;band_indices should be a dictionary&quot;</span><span class="p">)</span>

        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">input_band_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                    <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">valid_indices_format</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                    <span class="n">valid_range_indices</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_indices_format</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_range_indices</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

                <span class="n">band_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>  <span class="c1"># type: ignore</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">band_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_overlapping_segments</span><span class="p">(</span><span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check for overlapping segments in the given hsi.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The hsi object containing the wavelengths.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]):</span>
<span class="sd">                A dictionary mapping segment labels to indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlapping_segments</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">dict_labels_to_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="ow">in</span> <span class="n">overlapping_segments</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Segments </span><span class="si">{</span><span class="n">overlapping_segments</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2"> are overlapping on wavelength </span><span class="si">{</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">overlapping_segments</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">=</span> <span class="n">segment_label</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_and_create_dict_labels_to_segment_ids</span><span class="p">(</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">segment_labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates and creates a dictionary mapping segment labels to segment IDs.</span>

<span class="sd">        Args:</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int] | None):</span>
<span class="sd">                The existing mapping from segment labels to segment IDs, or None if it doesn&#39;t exist.</span>
<span class="sd">            segment_labels (list[str | tuple[str, ...]]): The list of segment labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str | tuple[str, ...], int]: A tuple containing the validated dictionary mapping segment</span>
<span class="sd">            labels to segment IDs and a boolean flag indicating whether the segment labels are hashed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of `dict_labels_to_segment_ids` doesn&#39;t match the length of `segment_labels`.</span>
<span class="sd">            ValueError: If a segment label is not present in `dict_labels_to_segment_ids`.</span>
<span class="sd">            ValueError: If there are non-unique segment IDs in `dict_labels_to_segment_ids`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dict_labels_to_segment_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating mapping from segment labels into ids&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">segment</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)}</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using existing mapping from segment labels into segment ids&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect dict_labels_to_segment_ids - length mismatch. Expected: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">, Actual: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">unique_segment_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_segment_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non unique segment ids in the dict_labels_to_segment_ids&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Passed mapping is correct&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dict_labels_to_segment_ids</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_single_dim_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a one-dimensional band mask based on the given image, labels, and segment IDs.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]):</span>
<span class="sd">                A dictionary mapping labels or label tuples to lists of indices.</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int]):</span>
<span class="sd">                A dictionary mapping labels or label tuples to segment IDs.</span>
<span class="sd">            device (torch.device): The device to use for the tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The one-dimensional band mask tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the indices for a segment are out of bounds for the one-dimensional band mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_mask_single_dim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="n">segment_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">segment_label</span> <span class="ow">in</span> <span class="n">segment_labels</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">segment_indices</span> <span class="o">=</span> <span class="n">dict_labels_to_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">dict_labels_to_segment_ids</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span>
            <span class="n">are_indices_valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">segment_indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">are_indices_valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Indices for segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2"> are out of bounds for the one-dimensional band mask&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of shape </span><span class="si">{</span><span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">band_mask_single_dim</span><span class="p">[</span><span class="n">segment_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment_id</span>

        <span class="k">return</span> <span class="n">band_mask_single_dim</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_expand_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">band_mask_single_dim</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expands the band mask to match the dimensions of the input hsi.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            band_mask_single_dim (torch.Tensor): The band mask tensor with a single dimension.</span>
<span class="sd">            repeat_dimensions (bool): Whether to repeat the dimensions of the band mask to match the hsi.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The expanded band mask tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">repeat_dimensions</span><span class="p">:</span>
            <span class="n">size_image</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
            <span class="n">size_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

            <span class="n">repeat_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">s2</span> <span class="o">//</span> <span class="n">s1</span> <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">size_mask</span><span class="p">,</span> <span class="n">size_image</span><span class="p">)]</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat_dims</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">band_mask</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_tensor_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a tensor band mask from dictionaries. The band mask is created based on the given hsi, labels, and</span>
<span class="sd">        segment IDs. The band mask is a tensor with the same shape as the input hsi and contains segment IDs, where each</span>
<span class="sd">        segment is represented by a unique ID. The band mask will be used to attribute the hsi using the LIME method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]): A dictionary mapping labels to indices.</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int] | None, optional):</span>
<span class="sd">                A dictionary mapping labels to segment IDs. Defaults to None.</span>
<span class="sd">            device (str | torch.device | None, optional): The device to use. Defaults to None.</span>
<span class="sd">            repeat_dimensions (bool, optional): Whether to repeat dimensions. Defaults to False.</span>
<span class="sd">            return_dict_labels_to_segment_ids (bool, optional):</span>
<span class="sd">                Whether to return the dictionary mapping labels to segment IDs. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor | tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]:</span>
<span class="sd">                The tensor band mask or a tuple containing the tensor band mask</span>
<span class="sd">                and the dictionary mapping labels to segment IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
        <span class="n">segment_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_labels_to_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating a band mask on the device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> using </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)</span><span class="si">}</span><span class="s2"> segments&quot;</span><span class="p">)</span>

        <span class="c1"># Check for overlapping segments</span>
        <span class="n">Lime</span><span class="o">.</span><span class="n">_check_overlapping_segments</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">dict_labels_to_indices</span><span class="p">)</span>

        <span class="c1"># Create or validate dict_labels_to_segment_ids</span>
        <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_validate_and_create_dict_labels_to_segment_ids</span><span class="p">(</span>
            <span class="n">dict_labels_to_segment_ids</span><span class="p">,</span> <span class="n">segment_labels</span>
        <span class="p">)</span>

        <span class="c1"># Create single-dimensional band mask</span>
        <span class="n">band_mask_single_dim</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_single_dim_band_mask</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span> <span class="n">dict_labels_to_indices</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span><span class="p">,</span> <span class="n">device</span>
        <span class="p">)</span>

        <span class="c1"># Expand band mask to match image dimensions</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_expand_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask_single_dim</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_dict_labels_to_segment_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span>
        <span class="k">return</span> <span class="n">band_mask</span>

    <span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;slic&quot;</span><span class="p">,</span> <span class="s2">&quot;patch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpatialAttributes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask</span>
<span class="sd">        LIME method attributes the `superpixels` provided by the segmentation mask. Please refer to the original paper</span>
<span class="sd">        `https://arxiv.org/abs/1602.04938` for more details or to Christoph Molnar&#39;s book</span>
<span class="sd">        `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">        This function attributes the hsi using the LIME (Local Interpretable Model-Agnostic Explanations)</span>
<span class="sd">        method for spatial data. It returns an `HSISpatialAttributes` object that contains the hsi,</span>
<span class="sd">        the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">            segmentation_mask (np.ndarray | torch.Tensor | None, optional):</span>
<span class="sd">                A segmentation mask according to which the attribution should be performed.</span>
<span class="sd">                If None, a new segmentation mask is created using the `segmentation_method`.</span>
<span class="sd">                    Additional parameters for the segmentation method may be passed as kwargs. Defaults to None.</span>
<span class="sd">            target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">            perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">                Defaults to 4.</span>
<span class="sd">            verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">            postprocessing_segmentation_output (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):</span>
<span class="sd">               A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">               lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">               inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">                   Defaults to None.</span>
<span class="sd">            segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">                Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">            **segmentation_method_params (Any): Additional parameters for the segmentation method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSISpatialAttributes: An `HSISpatialAttributes` object that contains the hsi, the attributions,</span>
<span class="sd">                the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">            AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">            AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">            &gt;&gt;&gt; lime = mt_lime.Lime(</span>
<span class="sd">                    explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">                )</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution = lime.get_spatial_attributes(hsi, segmentation_mask=segmentation_mask, target=0)</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.attributes.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.score</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
                <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
                <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
            <span class="p">)</span>
            <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">segmentation_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span>
            <span class="n">segmentation_mask</span><span class="p">,</span> <span class="s2">&quot;Segmentation mask should be None, numpy array, or torch tensor&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">feature_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
            <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">HSISpatialAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
            <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">spatial_attribution</span>

    <span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">band_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpectralAttributes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME</span>
<span class="sd">        method attributes the hsi based on `superbands` (clustered bands) provided by the band mask.</span>
<span class="sd">        Please refer to the original paper `https://arxiv.org/abs/1602.04938` for more details or to</span>
<span class="sd">        Christoph Molnar&#39;s book `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">        The function returns an HSISpectralAttributes object that contains the hsi, the attributions, the band mask,</span>
<span class="sd">        the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">            band_mask (np.ndarray | torch.Tensor | None, optional): Band mask that is used for the spectral attribution.</span>
<span class="sd">                If equals to None, the band mask is created within the function. Defaults to None.</span>
<span class="sd">            target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">            perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">                Defaults to 4.</span>
<span class="sd">            verbose (bool, optional): Specifies whether to show progress during the attribution process. Defaults to False.</span>
<span class="sd">            postprocessing_segmentation_output: (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):</span>
<span class="sd">                A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">                lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">                inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            band_names (list[str] | dict[str | tuple[str, ...], int] | None, optional): Band names. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSISpectralAttributes: An HSISpectralAttributes object containing the hsi, the attributions,</span>
<span class="sd">                the band mask, the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">            AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">            AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">            &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">            &gt;&gt;&gt; lime = mt_lime.Lime(</span>
<span class="sd">                    explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">                )</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution = lime.get_spectral_attributes(hsi, band_mask=band_mask, band_names=band_names, target=0)</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.attributes.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.band_mask.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.band_names</span>
<span class="sd">            [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.score</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
                <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
                <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
            <span class="p">)</span>
            <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

        <span class="k">if</span> <span class="n">band_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="s2">&quot;Band mask should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_expand_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_segments</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># checking consistency of names</span>
            <span class="c1"># unique_segments = torch.unique(band_mask)</span>
            <span class="c1"># if isinstance(band_names, dict):</span>
            <span class="c1">#     assert set(unique_segments).issubset(set(band_names.values())), &quot;Incorrect band names&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Band names are provided, using them. In future it there should be an option to validate them&quot;</span><span class="p">)</span>

        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">feature_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
            <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">HSISpectralAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
            <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
            <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">spectral_attribution</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_slick_segmentation_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">num_interpret_features</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a segmentation mask using the SLIC method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the segmentation mask is created.</span>
<span class="sd">            num_interpret_features (int, optional): Number of segments. Defaults to 10.</span>
<span class="sd">            *args: Additional positional arguments to be passed to the SLIC method.</span>
<span class="sd">            **kwargs: Additional keyword arguments to be passed to the SLIC method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: An output segmentation mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">slic</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="n">n_segments</span><span class="o">=</span><span class="n">num_interpret_features</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spatial_mask</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="n">channel_axis</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">segmentation_mask</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segmentation_mask</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a segmentation mask using the patch method - creates small squares of the same size</span>
<span class="sd">            and assigns a unique value to each square.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the segmentation mask is created.</span>
<span class="sd">            patch_size (int, optional): Size of the patch, the hsi size should be divisible by this value.</span>
<span class="sd">                Defaults to 10.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: An output segmentation mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Patch segmentation only works for band_index = 0 now&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">patch_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patch_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid patch_size. patch_size must be a positive integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">patch_size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">%</span> <span class="n">patch_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid patch_size. patch_size must be a factor of both width and height of the hsi&quot;</span><span class="p">)</span>

        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">height</span> <span class="o">//</span> <span class="n">patch_size</span> <span class="o">*</span> <span class="n">width</span> <span class="o">//</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">height</span> <span class="o">//</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">width</span> <span class="o">//</span> <span class="n">patch_size</span>
        <span class="p">)</span>
        <span class="n">idx_mask</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">idx_mask</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span> <span class="o">*</span> <span class="n">hsi</span><span class="o">.</span><span class="n">spatial_mask</span>
        <span class="c1"># segmentation_mask = torch.repeat_interleave(</span>
        <span class="c1"># torch.unsqueeze(segmentation_mask, dim=hsi.spectral_axis),</span>
        <span class="c1"># repeats=hsi.image.shape[hsi.spectral_axis], dim=hsi.spectral_axis)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

        <span class="n">mask_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask_idx</span><span class="p">):</span>
            <span class="n">segmentation_mask</span><span class="p">[</span><span class="n">segmentation_mask</span> <span class="o">==</span> <span class="n">mask_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="k">return</span> <span class="n">segmentation_mask</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.Lime.get_band_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_wavelengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Generates a band mask based on the provided hsi and band information.</p>
<p>Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.
If you provide more than one, the band mask will be created using only one using the following priority:
band_names &gt; band_wavelengths &gt; band_indices.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input hsi.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_names</code></td>
            <td>
                  <code>None | list[str | list[str]] | dict[tuple[str, ...] | str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The names of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_indices</code></td>
            <td>
                  <code>None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_wavelengths</code></td>
            <td>
                  <code>None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str | <span title="torch.device">device</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to use for computation. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>repeat_dimensions</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>dict[tuple[str, ...] | str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>mapping band names to segment IDs.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If no band names, indices, or wavelengths are provided.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_indices</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;RGB&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_indices</span><span class="o">=</span><span class="n">band_indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;RGB&quot;: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_wavelengths</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;RGB&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">),</span> <span class="p">(</span><span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">),</span> <span class="p">(</span><span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">)]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_wavelengths</span><span class="o">=</span><span class="n">band_wavelengths</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;RGB&quot;: 1}</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span>
<span class="normal">985</span>
<span class="normal">986</span>
<span class="normal">987</span>
<span class="normal">988</span>
<span class="normal">989</span>
<span class="normal">990</span>
<span class="normal">991</span>
<span class="normal">992</span>
<span class="normal">993</span>
<span class="normal">994</span>
<span class="normal">995</span>
<span class="normal">996</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">get_band_mask</span><span class="p">(</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_indices</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_wavelengths</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a band mask based on the provided hsi and band information.</span>

<span class="sd">    Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.</span>
<span class="sd">    If you provide more than one, the band mask will be created using only one using the following priority:</span>
<span class="sd">    band_names &gt; band_wavelengths &gt; band_indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): The input hsi.</span>
<span class="sd">        band_names (None | list[str | list[str]] | dict[tuple[str, ...] | str, int], optional):</span>
<span class="sd">            The names of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        band_indices (None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]], optional):</span>
<span class="sd">            The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        band_wavelengths (None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float], optional):</span>
<span class="sd">            The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        device (str | torch.device | None, optional):</span>
<span class="sd">            The device to use for computation. Defaults to None.</span>
<span class="sd">        repeat_dimensions (bool, optional):</span>
<span class="sd">            Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</span>
<span class="sd">        mapping band names to segment IDs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">        ValueError: If no band names, indices, or wavelengths are provided.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((len(wavelengths), 10, 10)), wavelengths=wavelengths)</span>
<span class="sd">        &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;]</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_names=band_names)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="sd">        &gt;&gt;&gt; band_indices = {&quot;RGB&quot;: [0, 1, 2]}</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_indices=band_indices)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;RGB&quot;: 1}</span>
<span class="sd">        &gt;&gt;&gt; band_wavelengths = {&quot;RGB&quot;: [(462.08, 465.27), (465.27, 468.47), (468.47, 471.68)]}</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_wavelengths=band_wavelengths)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;RGB&quot;: 1}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">),</span> <span class="s2">&quot;No band names, indices, or wavelengths are provided.&quot;</span>

    <span class="c1"># validate types</span>
    <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band names of spectral bands&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Only the band names will be used to create the band mask&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>
            <span class="n">band_groups</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_names</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect band names provided: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">elif</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of wavelengths&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Only the band wavelengths will be used to create the band mask&quot;</span><span class="p">)</span>
        <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span>
                <span class="n">band_wavelengths</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges wavelengths provided, please check if provided wavelengths are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">elif</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of indices&quot;</span><span class="p">)</span>
        <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_indices</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_indices&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_input_band_indices</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_indices</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges indices provided, please check if provided indices are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_tensor_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">,</span>
        <span class="n">band_groups</span><span class="p">,</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="o">=</span><span class="n">dict_labels_to_segment_ids</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="o">=</span><span class="n">repeat_dimensions</span><span class="p">,</span>
        <span class="n">return_dict_labels_to_segment_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.Lime.get_segmentation_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s1">&#39;slic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Generates a segmentation mask for the given hsi using the specified segmentation method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input hsi for which the segmentation mask needs to be generated.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segmentation_method</code></td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;patch&#39;, &#39;slic&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The segmentation method to be used.
Defaults to "slic".</p>
              </div>
            </td>
            <td>
                  <code>&#39;slic&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>**segmentation_method_params</code></td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional parameters specific to the chosen segmentation method.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The segmentation mask as a tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an unsupported segmentation method is specified.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s2">&quot;slic&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">torch.tensor([[1, 1],</span>
<span class="go">              [1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">torch.tensor([[2, 2],</span>
<span class="go">              [2, 2]])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">get_segmentation_mask</span><span class="p">(</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;slic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a segmentation mask for the given hsi using the specified segmentation method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): The input hsi for which the segmentation mask needs to be generated.</span>
<span class="sd">        segmentation_method (Literal[&quot;patch&quot;, &quot;slic&quot;], optional): The segmentation method to be used.</span>
<span class="sd">            Defaults to &quot;slic&quot;.</span>
<span class="sd">        **segmentation_method_params (Any): Additional parameters specific to the chosen segmentation method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The segmentation mask as a tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">        ValueError: If an unsupported segmentation method is specified.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((3, 240, 240)), wavelengths=[462.08, 465.27, 468.47])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;slic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;patch&quot;, patch_size=2)</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask[0, :2, :2]</span>
<span class="sd">        torch.tensor([[1, 1],</span>
<span class="sd">                      [1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask[0, 2:4, :2]</span>
<span class="sd">        torch.tensor([[2, 2],</span>
<span class="sd">                      [2, 2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image should be an instance of Image class&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;slic&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_slick_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported segmentation method: </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.Lime.get_spatial_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">postprocessing_segmentation_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s1">&#39;slic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask
LIME method attributes the <code>superpixels</code> provided by the segmentation mask. Please refer to the original paper
<code>https://arxiv.org/abs/1602.04938</code> for more details or to Christoph Molnar's book
<code>https://christophm.github.io/interpretable-ml-book/lime.html</code>.</p>
<p>This function attributes the hsi using the LIME (Local Interpretable Model-Agnostic Explanations)
method for spatial data. It returns an <code>HSISpatialAttributes</code> object that contains the hsi,
the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An HSI object for which the attribution is performed.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segmentation_mask</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A segmentation mask according to which the attribution should be performed.
If None, a new segmentation mask is created using the <code>segmentation_method</code>.
    Additional parameters for the segmentation method may be passed as kwargs. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>target</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the model creates more than one output, it analyzes the given target.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>n_samples</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>perturbations_per_eval</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of perturbations to evaluate at once (Simply the inner batch size).
Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the progress bar. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>postprocessing_segmentation_output</code></td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>, <span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as
lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with
inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.
   Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segmentation_method</code></td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;slic&#39;, &#39;patch&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Segmentation method used only if <code>segmentation_mask</code> is None. Defaults to "slic".</p>
              </div>
            </td>
            <td>
                  <code>&#39;slic&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>**segmentation_method_params</code></td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional parameters for the segmentation method.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>HSISpatialAttributes</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.lime.HSISpatialAttributes" href="#src.meteors.lime.HSISpatialAttributes">HSISpatialAttributes</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An <code>HSISpatialAttributes</code> object that contains the hsi, the attributions,
the segmentation mask, and the score of the interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the Lime object is not initialized or is not an instance of LimeBase.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If explainable model type is <code>segmentation</code> and <code>postprocessing_segmentation_output</code> is not provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lime</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="p">(</span>
<span class="go">        explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">score</span>
<span class="go">1.0</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span>
<span class="normal">1507</span>
<span class="normal">1508</span>
<span class="normal">1509</span>
<span class="normal">1510</span>
<span class="normal">1511</span>
<span class="normal">1512</span>
<span class="normal">1513</span>
<span class="normal">1514</span>
<span class="normal">1515</span>
<span class="normal">1516</span>
<span class="normal">1517</span>
<span class="normal">1518</span>
<span class="normal">1519</span>
<span class="normal">1520</span>
<span class="normal">1521</span>
<span class="normal">1522</span>
<span class="normal">1523</span>
<span class="normal">1524</span>
<span class="normal">1525</span>
<span class="normal">1526</span>
<span class="normal">1527</span>
<span class="normal">1528</span>
<span class="normal">1529</span>
<span class="normal">1530</span>
<span class="normal">1531</span>
<span class="normal">1532</span>
<span class="normal">1533</span>
<span class="normal">1534</span>
<span class="normal">1535</span>
<span class="normal">1536</span>
<span class="normal">1537</span>
<span class="normal">1538</span>
<span class="normal">1539</span>
<span class="normal">1540</span>
<span class="normal">1541</span>
<span class="normal">1542</span>
<span class="normal">1543</span>
<span class="normal">1544</span>
<span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span>
<span class="normal">1551</span>
<span class="normal">1552</span>
<span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;slic&quot;</span><span class="p">,</span> <span class="s2">&quot;patch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpatialAttributes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask</span>
<span class="sd">    LIME method attributes the `superpixels` provided by the segmentation mask. Please refer to the original paper</span>
<span class="sd">    `https://arxiv.org/abs/1602.04938` for more details or to Christoph Molnar&#39;s book</span>
<span class="sd">    `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">    This function attributes the hsi using the LIME (Local Interpretable Model-Agnostic Explanations)</span>
<span class="sd">    method for spatial data. It returns an `HSISpatialAttributes` object that contains the hsi,</span>
<span class="sd">    the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">        segmentation_mask (np.ndarray | torch.Tensor | None, optional):</span>
<span class="sd">            A segmentation mask according to which the attribution should be performed.</span>
<span class="sd">            If None, a new segmentation mask is created using the `segmentation_method`.</span>
<span class="sd">                Additional parameters for the segmentation method may be passed as kwargs. Defaults to None.</span>
<span class="sd">        target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">        perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">            Defaults to 4.</span>
<span class="sd">        verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">        postprocessing_segmentation_output (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):</span>
<span class="sd">           A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">           lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">           inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">               Defaults to None.</span>
<span class="sd">        segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">            Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">        **segmentation_method_params (Any): Additional parameters for the segmentation method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSISpatialAttributes: An `HSISpatialAttributes` object that contains the hsi, the attributions,</span>
<span class="sd">            the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">        AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">        AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">        &gt;&gt;&gt; lime = mt_lime.Lime(</span>
<span class="sd">                explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">            )</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution = lime.get_spatial_attributes(hsi, segmentation_mask=segmentation_mask, target=0)</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.attributes.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.score</span>
<span class="sd">        1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
            <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
            <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
        <span class="p">)</span>
        <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">segmentation_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span>
        <span class="n">segmentation_mask</span><span class="p">,</span> <span class="s2">&quot;Segmentation mask should be None, numpy array, or torch tensor&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

    <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">feature_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
        <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">HSISpatialAttributes</span><span class="p">(</span>
        <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
        <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">spatial_attribution</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.lime.Lime.get_spectral_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">postprocessing_segmentation_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME
method attributes the hsi based on <code>superbands</code> (clustered bands) provided by the band mask.
Please refer to the original paper <code>https://arxiv.org/abs/1602.04938</code> for more details or to
Christoph Molnar's book <code>https://christophm.github.io/interpretable-ml-book/lime.html</code>.</p>
<p>The function returns an HSISpectralAttributes object that contains the hsi, the attributions, the band mask,
the band names, and the score of the interpretable model used for the explanation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An HSI object for which the attribution is performed.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_mask</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band mask that is used for the spectral attribution.
If equals to None, the band mask is created within the function. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>target</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the model creates more than one output, it analyzes the given target.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>n_samples</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>perturbations_per_eval</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of perturbations to evaluate at once (Simply the inner batch size).
Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifies whether to show progress during the attribution process. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>postprocessing_segmentation_output</code></td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>, <span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>(Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):
A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as
lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with
inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_names</code></td>
            <td>
                  <code>list[str] | dict[str | tuple[str, ...], int] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band names. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>HSISpectralAttributes</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.lime.HSISpectralAttributes" href="#src.meteors.lime.HSISpectralAttributes">HSISpectralAttributes</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An HSISpectralAttributes object containing the hsi, the attributions,
the band mask, the band names, and the score of the interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the Lime object is not initialized or is not an instance of LimeBase.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If explainable model type is <code>segmentation</code> and <code>postprocessing_segmentation_output</code> is not provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lime</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="p">(</span>
<span class="go">        explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">band_names</span>
<span class="go">[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">score</span>
<span class="go">1.0</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span>
<span class="normal">1580</span>
<span class="normal">1581</span>
<span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span>
<span class="normal">1605</span>
<span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span>
<span class="normal">1653</span>
<span class="normal">1654</span>
<span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">band_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpectralAttributes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME</span>
<span class="sd">    method attributes the hsi based on `superbands` (clustered bands) provided by the band mask.</span>
<span class="sd">    Please refer to the original paper `https://arxiv.org/abs/1602.04938` for more details or to</span>
<span class="sd">    Christoph Molnar&#39;s book `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">    The function returns an HSISpectralAttributes object that contains the hsi, the attributions, the band mask,</span>
<span class="sd">    the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">        band_mask (np.ndarray | torch.Tensor | None, optional): Band mask that is used for the spectral attribution.</span>
<span class="sd">            If equals to None, the band mask is created within the function. Defaults to None.</span>
<span class="sd">        target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">        perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">            Defaults to 4.</span>
<span class="sd">        verbose (bool, optional): Specifies whether to show progress during the attribution process. Defaults to False.</span>
<span class="sd">        postprocessing_segmentation_output: (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):</span>
<span class="sd">            A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">            lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">            inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        band_names (list[str] | dict[str | tuple[str, ...], int] | None, optional): Band names. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSISpectralAttributes: An HSISpectralAttributes object containing the hsi, the attributions,</span>
<span class="sd">            the band mask, the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">        AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">        AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">        &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">        &gt;&gt;&gt; lime = mt_lime.Lime(</span>
<span class="sd">                explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">            )</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution = lime.get_spectral_attributes(hsi, band_mask=band_mask, band_names=band_names, target=0)</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.attributes.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.band_mask.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.band_names</span>
<span class="sd">        [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.score</span>
<span class="sd">        1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
            <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
            <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
        <span class="p">)</span>
        <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

    <span class="k">if</span> <span class="n">band_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="s2">&quot;Band mask should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_expand_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_segments</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
        <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># checking consistency of names</span>
        <span class="c1"># unique_segments = torch.unique(band_mask)</span>
        <span class="c1"># if isinstance(band_names, dict):</span>
        <span class="c1">#     assert set(unique_segments).issubset(set(band_names.values())), &quot;Incorrect band names&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Band names are provided, using them. In future it there should be an option to validate them&quot;</span><span class="p">)</span>

    <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lime</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">feature_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
        <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">HSISpectralAttributes</span><span class="p">(</span>
        <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
        <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">spectral_attribution</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.adjust_and_validate_segment_ranges" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_ranges</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Adjusts and validates segment ranges against the wavelength dimension.</p>
<p>This function ensures that each segment range is within the bounds of the wavelength
dimension. It attempts to adjust out-of-bounds ranges when possible and raises an
error for ranges that cannot be adjusted.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>wavelengths</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wavelengths tensor. Its length determines the
valid range for segments.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segment_ranges</code></td>
            <td>
                  <code>list[tuple[int, int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of segment ranges to be validated
and potentially adjusted. Each tuple represents (start, end) indices.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>list[tuple[int, int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>list[tuple[int, int]]: The list of validated and potentially adjusted segment ranges.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a segment range is entirely out of bounds and cannot be adjusted.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Warns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>UserWarning</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a segment range is partially out of bounds and is adjusted.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Segment ranges are inclusive of both start and end indices.</li>
<li>Ranges extending below 0 are adjusted to start at 0 if possible.</li>
<li>Ranges extending beyond the wavelength dimension are truncated if possible.</li>
<li>Adjustments are only made if at least part of the range is within bounds.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">adjust_and_validate_segment_ranges</span><span class="p">(</span>
    <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">segment_ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjusts and validates segment ranges against the wavelength dimension.</span>

<span class="sd">    This function ensures that each segment range is within the bounds of the wavelength</span>
<span class="sd">    dimension. It attempts to adjust out-of-bounds ranges when possible and raises an</span>
<span class="sd">    error for ranges that cannot be adjusted.</span>

<span class="sd">    Args:</span>
<span class="sd">        wavelengths (torch.Tensor): The wavelengths tensor. Its length determines the</span>
<span class="sd">            valid range for segments.</span>
<span class="sd">        segment_ranges (list[tuple[int, int]]): A list of segment ranges to be validated</span>
<span class="sd">            and potentially adjusted. Each tuple represents (start, end) indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[tuple[int, int]]: The list of validated and potentially adjusted segment ranges.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If a segment range is entirely out of bounds and cannot be adjusted.</span>

<span class="sd">    Warns:</span>
<span class="sd">        UserWarning: If a segment range is partially out of bounds and is adjusted.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Segment ranges are inclusive of both start and end indices.</span>
<span class="sd">        - Ranges extending below 0 are adjusted to start at 0 if possible.</span>
<span class="sd">        - Ranges extending beyond the wavelength dimension are truncated if possible.</span>
<span class="sd">        - Adjustments are only made if at least part of the range is within bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)</span>
    <span class="n">adjusted_ranges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">segment_ranges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adjusting segment start from </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> to 0&quot;</span><span class="p">)</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Segment range </span><span class="si">{</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="si">}</span><span class="s2"> is out of bounds&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adjusting segment end from </span><span class="si">{</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">max_index</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">max_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Segment range </span><span class="si">{</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="si">}</span><span class="s2"> is out of bounds&quot;</span><span class="p">)</span>
        <span class="n">adjusted_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">adjusted_ranges</span>  <span class="c1"># type: ignore</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.align_band_names_with_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">align_band_names_with_mask</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Aligns the band names dictionary with the unique values in the band mask.</p>
<p>This function ensures that the band_names dictionary correctly represents all unique
values in the band_mask. It adds a 'not_included' category if necessary and validates
that all mask values are accounted for in the band names.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>band_names</code></td>
            <td>
                  <code>dict[str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary mapping band names to their corresponding
                         integer values in the mask.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_mask</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A tensor representing the band mask, where each unique
                      integer corresponds to a different band or category.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>dict[str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dict[str, int]: The updated band_names dictionary, potentially including a
            'not_included' category if 0 is present in the mask but not in
            the original band_names.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the set of values in band_names doesn't match the unique values
        in the band_mask after accounting for the 'not_included' category.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Warns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>UserWarning</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a 'not_included' category (0) is added to the band_names.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The function assumes that 0 in the mask represents 'not_included' areas if
  not explicitly defined in the input band_names.</li>
<li>All unique values in the mask must be present in the band_names dictionary
  after the alignment process.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">align_band_names_with_mask</span><span class="p">(</span><span class="n">band_names</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">band_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Aligns the band names dictionary with the unique values in the band mask.</span>

<span class="sd">    This function ensures that the band_names dictionary correctly represents all unique</span>
<span class="sd">    values in the band_mask. It adds a &#39;not_included&#39; category if necessary and validates</span>
<span class="sd">    that all mask values are accounted for in the band names.</span>

<span class="sd">    Args:</span>
<span class="sd">        band_names (dict[str, int]): A dictionary mapping band names to their corresponding</span>
<span class="sd">                                     integer values in the mask.</span>
<span class="sd">        band_mask (torch.Tensor): A tensor representing the band mask, where each unique</span>
<span class="sd">                                  integer corresponds to a different band or category.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict[str, int]: The updated band_names dictionary, potentially including a</span>
<span class="sd">                        &#39;not_included&#39; category if 0 is present in the mask but not in</span>
<span class="sd">                        the original band_names.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the set of values in band_names doesn&#39;t match the unique values</span>
<span class="sd">                    in the band_mask after accounting for the &#39;not_included&#39; category.</span>

<span class="sd">    Warns:</span>
<span class="sd">        UserWarning: If a &#39;not_included&#39; category (0) is added to the band_names.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function assumes that 0 in the mask represents &#39;not_included&#39; areas if</span>
<span class="sd">          not explicitly defined in the input band_names.</span>
<span class="sd">        - All unique values in the mask must be present in the band_names dictionary</span>
<span class="sd">          after the alignment process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_mask_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_mask</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">band_name_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># Check if 0 is in the mask but not in band_names</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">unique_mask_values</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">band_name_values</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Band mask contains `0` values which are not covered by the provided band names. &quot;</span>
            <span class="s2">&quot;Adding &#39;not_included&#39; to band names.&quot;</span>
        <span class="p">)</span>
        <span class="n">band_names</span><span class="p">[</span><span class="s2">&quot;not_included&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">band_name_values</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Validate that all mask values are in band_names</span>
    <span class="k">if</span> <span class="n">unique_mask_values</span> <span class="o">!=</span> <span class="n">band_name_values</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Band names should have all unique values in mask&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">band_names</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.ensure_torch_tensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Ensures the input is a PyTorch tensor, converting it if necessary.</p>
<p>This function validates that the input is either a NumPy array or a PyTorch tensor,
and converts NumPy arrays to PyTorch tensors. It's useful for standardizing inputs
in functions that require PyTorch tensors.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>value</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input value to be validated and potentially converted.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>context</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string describing the context of the conversion, used in error and debug messages.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The input value as a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input is neither a NumPy array nor a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ensure_torch_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensures the input is a PyTorch tensor, converting it if necessary.</span>

<span class="sd">    This function validates that the input is either a NumPy array or a PyTorch tensor,</span>
<span class="sd">    and converts NumPy arrays to PyTorch tensors. It&#39;s useful for standardizing inputs</span>
<span class="sd">    in functions that require PyTorch tensors.</span>

<span class="sd">    Args:</span>
<span class="sd">        value (np.ndarray | torch.Tensor): The input value to be validated and potentially converted.</span>
<span class="sd">        context (str): A string describing the context of the conversion, used in error and debug messages.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The input value as a PyTorch tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input is neither a NumPy array nor a PyTorch tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2"> from NumPy array to PyTorch tensor&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2"> must be a NumPy array or PyTorch tensor&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.resolve_inference_device" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">resolve_inference_device</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Resolves and returns the device to be used for inference.</p>
<p>This function determines the appropriate PyTorch device for inference based on the input
parameters and available information. It handles three scenarios:
1. If a specific device is provided, it validates and returns it.
2. If no device is specified (None), it uses the device of the input hsi.
3. If a string is provided, it attempts to convert it to a torch.device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str | <span title="torch.device">device</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The desired device for inference.
If None, the device of the input hsi will be used.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>info</code></td>
            <td>
                  <code><span title="pydantic.ValidationInfo">ValidationInfo</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An object containing additional validation information,
including the input hsi data.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.device: The resolved PyTorch device for inference.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If no device is specified and the hsi is not present in the info data,
or if the provided device string is invalid.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the provided device is neither None, a string, nor a torch.device.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">resolve_inference_device</span><span class="p">(</span><span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="p">:</span> <span class="n">ValidationInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Resolves and returns the device to be used for inference.</span>

<span class="sd">    This function determines the appropriate PyTorch device for inference based on the input</span>
<span class="sd">    parameters and available information. It handles three scenarios:</span>
<span class="sd">    1. If a specific device is provided, it validates and returns it.</span>
<span class="sd">    2. If no device is specified (None), it uses the device of the input hsi.</span>
<span class="sd">    3. If a string is provided, it attempts to convert it to a torch.device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str | torch.device | None): The desired device for inference.</span>
<span class="sd">            If None, the device of the input hsi will be used.</span>
<span class="sd">        info (ValidationInfo): An object containing additional validation information,</span>
<span class="sd">            including the input hsi data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.device: The resolved PyTorch device for inference.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If no device is specified and the hsi is not present in the info data,</span>
<span class="sd">            or if the provided device string is invalid.</span>
<span class="sd">        TypeError: If the provided device is neither None, a string, nor a torch.device.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;hsi&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;HSI is not present in the data, INTERNAL ERROR&quot;</span><span class="p">)</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hsi&quot;</span><span class="p">]</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> is not valid&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Device should be a string or torch device&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Device for inference: </span><span class="si">{</span><span class="n">device</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">device</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_and_convert_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_and_convert_attributes</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates and converts the attributes to a PyTorch tensor.</p>
<p>This function ensures that the input attributes are in the correct format
(either a NumPy array or a PyTorch tensor) and converts them to a PyTorch
tensor if necessary.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>value</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The attributes to be validated and potentially converted.
This can be either a NumPy array or a PyTorch tensor.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The attributes as a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input is neither a NumPy array nor a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_and_convert_attributes</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates and converts the attributes to a PyTorch tensor.</span>

<span class="sd">    This function ensures that the input attributes are in the correct format</span>
<span class="sd">    (either a NumPy array or a PyTorch tensor) and converts them to a PyTorch</span>
<span class="sd">    tensor if necessary.</span>

<span class="sd">    Args:</span>
<span class="sd">        value (np.ndarray | torch.Tensor): The attributes to be validated and potentially converted.</span>
<span class="sd">            This can be either a NumPy array or a PyTorch tensor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The attributes as a PyTorch tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input is neither a NumPy array nor a PyTorch tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;Attributes&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_and_convert_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_and_convert_mask</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Ensures the <code>superpixel</code> or <code>superband</code> mask is a PyTorch tensor if provided, converting it if necessary.</p>
<p>This function validates that the input mask is either a NumPy array
or a PyTorch tensor, and converts it to a PyTorch tensor if it's a NumPy array.
if the input is None, it returns None.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>value</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The mask to be validated and potentially converted.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor | None: The mask as a PyTorch tensor or None if the input is None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input is neither a NumPy array nor a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_and_convert_mask</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensures the `superpixel` or `superband` mask is a PyTorch tensor if provided, converting it if necessary.</span>

<span class="sd">    This function validates that the input mask is either a NumPy array</span>
<span class="sd">    or a PyTorch tensor, and converts it to a PyTorch tensor if it&#39;s a NumPy array.</span>
<span class="sd">    if the input is None, it returns None.</span>

<span class="sd">    Args:</span>
<span class="sd">        value (np.ndarray | torch.Tensor | None): The mask to be validated and potentially converted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor | None: The mask as a PyTorch tensor or None if the input is None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input is neither a NumPy array nor a PyTorch tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;`superpixel` or `superband` mask&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_band_format" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_band_format</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validate the band format for a given variable.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>bands</code></td>
            <td>
                  <code>dict[str | tuple[str, ...], <span title="src.meteors.lime.BandType">BandType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary containing band ranges or list of wavelengths.
The keys can be either a string or a tuple of strings. The values can be a single value, a tuple of two values, or a list of values.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>variable_name</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the variable being validated.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the keys are not a string or a tuple of strings, or if the values do not match the expected types.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>None</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_band_format</span><span class="p">(</span><span class="n">bands</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">BandType</span><span class="p">],</span> <span class="n">variable_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate the band format for a given variable.</span>

<span class="sd">    Args:</span>
<span class="sd">        bands (dict[str | tuple[str, ...], BandType]): A dictionary containing band ranges or list of wavelengths.</span>
<span class="sd">            The keys can be either a string or a tuple of strings. The values can be a single value, a tuple of two values, or a list of values.</span>
<span class="sd">        variable_name (str): The name of the variable being validated.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the keys are not a string or a tuple of strings, or if the values do not match the expected types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">keys</span><span class="p">,</span> <span class="n">band_ranges</span> <span class="ow">in</span> <span class="n">bands</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s2"> keys should be string or tuple of strings&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">band_ranges</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">band_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">band_ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">all</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">band_ranges</span>
            <span class="p">)</span>
            <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">band_ranges</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s2"> should be either a value, list of values, &quot;</span>
                <span class="s2">&quot;tuple of two values or list of tuples of two values.&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_band_names" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates the band names provided.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>band_names</code></td>
            <td>
                  <code>list[str | list[str]] | dict[tuple[str, ...] | str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The band names to validate.
It can be either a list of strings or lists of strings, or a dictionary with keys as tuples or strings
and values as integers.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the band_names is not a list or a dictionary, or if the items in the list or the keys in the
dictionary are not of the expected types.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>None</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates the band names provided.</span>

<span class="sd">    Args:</span>
<span class="sd">        band_names (list[str | list[str]] | dict[tuple[str, ...] | str, int]): The band names to validate.</span>
<span class="sd">            It can be either a list of strings or lists of strings, or a dictionary with keys as tuples or strings</span>
<span class="sd">            and values as integers.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the band_names is not a list or a dictionary, or if the items in the list or the keys in the</span>
<span class="sd">            dictionary are not of the expected types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">band_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">key</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All keys in band_names dictionary should be str or tuple of str.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All values in band_names dictionary should be int.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">band_names</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All items in band_names list should be str or list of str.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;band_names should be either a list or a dictionary.&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_segment_format" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_segment_format</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates the format of the segment.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>segment</code></td>
            <td>
                  <code>tuple[int | float, int | float] | list[tuple[int | float, int | float]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The segment to validate.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>dtype</code></td>
            <td>
                  <code><span title="typing_extensions.Type">Type</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The data type of the segment range. Defaults to int.</p>
              </div>
            </td>
            <td>
                  <code>int</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>list[tuple[<span title="src.meteors.lime.IntOrFloat">IntOrFloat</span>, <span title="src.meteors.lime.IntOrFloat">IntOrFloat</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>list[tuple[int | float, int | float]]: The validated segment range.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the segment range is not in the correct format.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_segment_format</span><span class="p">(</span>
    <span class="n">segment</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">IntOrFloat</span><span class="p">,</span> <span class="n">IntOrFloat</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntOrFloat</span><span class="p">,</span> <span class="n">IntOrFloat</span><span class="p">]],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntOrFloat</span><span class="p">,</span> <span class="n">IntOrFloat</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates the format of the segment.</span>

<span class="sd">    Args:</span>
<span class="sd">        segment (tuple[int | float, int | float] | list[tuple[int | float, int | float]]):</span>
<span class="sd">            The segment to validate.</span>
<span class="sd">        dtype (Type, optional): The data type of the segment range. Defaults to int.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[tuple[int | float, int | float]]: The validated segment range.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the segment range is not in the correct format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Converting tuple segment to list of tuples&quot;</span><span class="p">)</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span><span class="p">]</span>  <span class="c1"># Standardize single tuple to list of tuples</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_segment</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_segment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">sub_segment</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">sub_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sub_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_segment</span> <span class="ow">in</span> <span class="n">segment</span>
        <span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Each segment range should be a tuple or list of two numbers of data type </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> (start, end). &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Where start &lt; end. But got: </span><span class="si">{</span><span class="n">segment</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">segment</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_segment_range" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_segment_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_range</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates the segment range and adjusts it if possible.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>wavelengths</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wavelengths tensor.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segment_range</code></td>
            <td>
                  <code>list[tuple[int, int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The segment range to be validated.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>list[tuple[int, int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>list[tuple[int, int]]: The validated segment range.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the segment range is out of bounds.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_segment_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">segment_range</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates the segment range and adjusts it if possible.</span>

<span class="sd">    Args:</span>
<span class="sd">        wavelengths (torch.Tensor): The wavelengths tensor.</span>
<span class="sd">        segment_range (list[tuple[int, int]]): The segment range to be validated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[tuple[int, int]]: The validated segment range.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the segment range is out of bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wavelengths_max_index</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out_segment_range</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segment_range</span><span class="p">:</span>
        <span class="n">new_segment</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Segment range </span><span class="si">{</span><span class="n">segment</span><span class="si">}</span><span class="s2"> is out of bounds&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">wavelengths_max_index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wavelengths_max_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wavelengths_max_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Segment range </span><span class="si">{</span><span class="n">segment</span><span class="si">}</span><span class="s2"> is out of bounds&quot;</span><span class="p">)</span>
        <span class="n">out_segment_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_segment</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out_segment_range</span>  <span class="c1"># type: ignore</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_shapes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_shapes</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">hsi</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates that the shape of the attributes tensor matches the shape of the image.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>attributes</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The attributes tensor to validate.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The hsi object to compare the shape with.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the shape of the attributes tensor does not match the shape of the hsi.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_shapes</span><span class="p">(</span><span class="n">attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates that the shape of the attributes tensor matches the shape of the image.</span>

<span class="sd">    Args:</span>
<span class="sd">        attributes (torch.Tensor): The attributes tensor to validate.</span>
<span class="sd">        hsi (HSI): The hsi object to compare the shape with.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the shape of the attributes tensor does not match the shape of the hsi.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attributes</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attributes must have the same shape as the hsi&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.lime.validate_tensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">error_message</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates the input value and converts it to a torch.Tensor if necessary.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>value</code></td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input value to be validated.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>error_message</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The error message to be raised if the value is not valid.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The validated and converted tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the value is not an instance of np.ndarray or torch.Tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">error_message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates the input value and converts it to a torch.Tensor if necessary.</span>

<span class="sd">    Args:</span>
<span class="sd">        value (Any): The input value to be validated.</span>
<span class="sd">        error_message (str): The error message to be raised if the value is not valid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The validated and converted tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the value is not an instance of np.ndarray or torch.Tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h3 id="lime-base">Lime Base</h3>
<p>The Lime Base class was adapted from the Captum Lime implementation. This adaptation builds upon the original work, extending and customizing it for specific use cases within this project. To see the original implementation, please refer to the <a href="https://captum.ai/api/_modules/captum/attr/_core/lime.html#LimeBase">Captum repository</a>.</p>
<h3 id="hyperspectral-image">HyperSpectral Image</h3>


<div class="doc doc-object doc-module">



<a id="src.meteors.hsi"></a>
    <div class="doc doc-contents first">



  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="src.meteors.hsi.HSI" class="doc doc-heading">
            <code>HSI</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="pydantic.BaseModel">BaseModel</span></code></p>


              <details class="quote">
                <summary>Source code in <code>src/meteors/hsi.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSI</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>  <span class="c1"># Should always be a first field</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">ensure_image_tensor</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Hyperspectral image. Converted to torch tensor.&quot;</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">wavelengths</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">ensure_wavelengths_tensor</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Wavelengths present in the image. Defaults to None.&quot;</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">validate_orientation</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s1">&#39;Orientation of the image - sequence of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot; &#39;</span>
                <span class="s1">&#39;meaning respectively channels, height and width of the image. Defaults to (&quot;C&quot;, &quot;H&quot;, &quot;W&quot;).&#39;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">)</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">resolve_inference_device</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Device to be used for inference. If None, the device of the input image will be used. Defaults to None.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">binary_mask</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">process_and_validate_binary_mask</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Binary mask used to cover not important parts of the base image, masked parts have values equals to 0. &quot;</span>
                <span class="s2">&quot;Converted to torch tensor. Defaults to None.&quot;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectral_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the index of the spectral (wavelength) axis based on the current data orientation.</span>

<span class="sd">        In hyperspectral imaging, the spectral axis represents the dimension along which</span>
<span class="sd">        different spectral bands or wavelengths are arranged. This property dynamically</span>
<span class="sd">        determines the index of this axis based on the current orientation of the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The index of the spectral axis in the current data structure.</span>
<span class="sd">                - 0 for &#39;CHW&#39; or &#39;CWH&#39; orientations (Channel/Wavelength first)</span>
<span class="sd">                - 2 for &#39;HWC&#39; or &#39;WHC&#39; orientations (Channel/Wavelength last)</span>
<span class="sd">                - 1 for &#39;HCW&#39; or &#39;WCH&#39; orientations (Channel/Wavelength in the middle)</span>

<span class="sd">        Note:</span>
<span class="sd">            The orientation is typically represented as a string where:</span>
<span class="sd">            - &#39;C&#39; represents the spectral/wavelength dimension</span>
<span class="sd">            - &#39;H&#39; represents the height (rows) of the image</span>
<span class="sd">            - &#39;W&#39; represents the width (columns) of the image</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI()</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.orientation = &quot;CHW&quot;</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spectral_axis</span>
<span class="sd">            0</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.orientation = &quot;HWC&quot;</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spectral_axis</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_channel_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spatial_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a 2D spatial representation of the binary mask.</span>

<span class="sd">        This property extracts a single 2D slice from the 3D binary mask, assuming that</span>
<span class="sd">        the mask is identical across all spectral bands. It handles different data</span>
<span class="sd">        orientations by first ensuring the spectral dimension is the last dimension</span>
<span class="sd">        before extracting the 2D spatial mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the spatial binary mask.</span>
<span class="sd">                The shape will be (H, W) where H is height and W is width of the image.</span>

<span class="sd">        Note:</span>
<span class="sd">            - This assumes that the binary mask is consistent across all spectral bands.</span>
<span class="sd">            - The returned mask is always 2D, regardless of the original data orientation.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # If self.binary_mask has shape (100, 100, 5) with spectral_axis=2:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(binary_mask=torch.rand(100, 100, 5), orientation=(&quot;H&quot;, &quot;W&quot;, &quot;C&quot;))</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spatial_mask.shape</span>
<span class="sd">            torch.Size([100, 100])</span>
<span class="sd">            &gt;&gt;&gt; If self.binary_mask has shape (5, 100, 100) with spectral_axis=0:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(binary_mask=torch.rand(5, 100, 100), orientation=(&quot;C&quot;, &quot;H&quot;, &quot;W&quot;))</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spatial_mask.shape</span>
<span class="sd">            torch.Size([100, 100])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span><span class="n">arbitrary_types_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_image_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the image data by checking the shape of the wavelengths, image, and spectral_axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the image and binary mask (if available) to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str or torch.device): The device to move the image and binary mask to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated Image object.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Create an HSI object</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 10, 10), wavelengths=np.arange(10))</span>
<span class="sd">            &gt;&gt;&gt; # Move the image to cpu</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cpu&quot;)</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # Move the image to cuda</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cuda&quot;)</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">            device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the hyperspectral image data with optional masking applied.</span>

<span class="sd">        Args:</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The hyperspectral image data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - If apply_mask is True, the binary mask will be applied to the image based on the `binary_mask` attribute.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">            &gt;&gt;&gt; image = hsi_image.get_image()</span>
<span class="sd">            &gt;&gt;&gt; image.shape</span>
<span class="sd">            torch.Size([10, 100, 100])</span>
<span class="sd">            &gt;&gt;&gt; image = hsi_image.get_image(apply_mask=False)</span>
<span class="sd">            &gt;&gt;&gt; image.shape</span>
<span class="sd">            torch.Size([10, 100, 100])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">apply_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

    <span class="k">def</span> <span class="nf">get_rgb_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts an RGB representation from the hyperspectral image data.</span>

<span class="sd">        This method creates a 3-channel RGB image by selecting appropriate bands</span>
<span class="sd">        corresponding to red, green, and blue wavelengths from the hyperspectral data.</span>

<span class="sd">        Args:</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity</span>
<span class="sd">                cutoff to the image. Defaults to False.</span>
<span class="sd">            output_channel_axis (int | None, optional): The axis where the RGB channels</span>
<span class="sd">                should be placed in the output tensor. If None, uses the current spectral</span>
<span class="sd">                axis of the hyperspectral data. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The RGB representation of the hyperspectral image.</span>
<span class="sd">                Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on</span>
<span class="sd">                the specified output_channel_axis, where H is height and W is width.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</span>
<span class="sd">            - Each band is normalized independently before combining into the RGB image.</span>
<span class="sd">            - If apply_mask is True, masked areas will be set to zero in the output.</span>
<span class="sd">            - If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image()</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([100, 100, 3])</span>

<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(output_channel_axis=0)</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([3, 100, 100])</span>

<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(apply_mask=False, apply_min_cutoff=True)</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([100, 100, 3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_channel_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>

        <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span>
                    <span class="n">band</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">rgb_img</span>
            <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>
            <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rgb_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_central_slice_from_band</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts and processes the central wavelength band from a given range in the hyperspectral image.</span>

<span class="sd">        This method selects the central band from a specified range of wavelengths,</span>
<span class="sd">        applies optional processing steps (masking, normalization, and minimum cutoff),</span>
<span class="sd">        and returns the resulting 2D image slice.</span>

<span class="sd">        Args:</span>
<span class="sd">            band_wavelengths (torch.Tensor): The selected wavelengths that define the whole band</span>
<span class="sd">                from which the central slice will be extracted.</span>
<span class="sd">                All of the passed wavelengths must be present in the image.</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff.</span>
<span class="sd">                If True, sets the minimum non-zero value to zero after normalization.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            normalize (bool, optional): Whether to normalize the band values to [0, 1] range.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the processed central wavelength band.</span>
<span class="sd">                Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The central wavelength is determined as the middle index of the provided wavelengths list.</span>
<span class="sd">            - If normalization is applied, it&#39;s done before masking and cutoff operations.</span>
<span class="sd">            - The binary mask, if applied, is expected to have the same spatial dimensions as the image.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(13, 100, 100), wavelengths=np.linspace(400, 1000, 13))</span>
<span class="sd">            &gt;&gt;&gt; band_wavelengths = torch.tensor([500, 600, 650, 700])</span>
<span class="sd">            &gt;&gt;&gt; central_slice = hsi_image._extract_central_slice_from_band(band_wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; central_slice.shape</span>
<span class="sd">            torch.Size([100, 100])</span>

<span class="sd">            &gt;&gt;&gt; # Extract a slice without normalization or masking</span>
<span class="sd">            &gt;&gt;&gt; raw_band = hsi_image._extract_central_slice_from_band(band_wavelengths, apply_mask=False, normalize=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if all wavelengths from the `band_wavelengths` are present in the image</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">wave</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="k">for</span> <span class="n">wave</span> <span class="ow">in</span> <span class="n">band_wavelengths</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All of the passed wavelengths must be present in the image&quot;</span><span class="p">)</span>

        <span class="c1"># sort the `band_wavelengths` to ensure the central band is selected</span>
        <span class="n">band_wavelengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">start_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">==</span> <span class="n">band_wavelengths</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">relative_center_band_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">central_band_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">relative_center_band_index</span>

        <span class="c1"># Ensure the spectral dimension is the last</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">slice</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">central_band_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">apply_min_cutoff</span><span class="p">:</span>
                <span class="n">slice_min</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">[</span><span class="nb">slice</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_min</span> <span class="o">=</span> <span class="nb">slice</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="n">slice_max</span> <span class="o">=</span> <span class="nb">slice</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">slice_max</span> <span class="o">&gt;</span> <span class="n">slice_min</span><span class="p">:</span>  <span class="c1"># Avoid division by zero</span>
                <span class="nb">slice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span> <span class="o">-</span> <span class="n">slice_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">slice_max</span> <span class="o">-</span> <span class="n">slice_min</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">apply_min_cutoff</span><span class="p">:</span>
                <span class="nb">slice</span><span class="p">[</span><span class="nb">slice</span> <span class="o">==</span> <span class="nb">slice</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set minimum values to zero</span>

        <span class="k">if</span> <span class="n">apply_mask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">slice</span> <span class="o">=</span> <span class="nb">slice</span> <span class="o">*</span> <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">central_band_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">slice</span>

    <span class="k">def</span> <span class="nf">extract_band_by_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">selection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts a single spectral band from the hyperspectral image based on a standardized band name.</span>

<span class="sd">        This method uses the spyndex library to map standardized band names to wavelength ranges,</span>
<span class="sd">        then extracts the corresponding band from the hyperspectral data.</span>

<span class="sd">        Args:</span>
<span class="sd">            band_name (str): The standardized name of the band to extract (e.g., &quot;Red&quot;, &quot;NIR&quot;, &quot;SWIR1&quot;).</span>
<span class="sd">            selection_method (str, optional): The method to use for selecting the band within the wavelength range.</span>
<span class="sd">                Currently, only &quot;center&quot; is supported, which selects the central wavelength.</span>
<span class="sd">                Defaults to &quot;center&quot;.</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff after normalization.</span>
<span class="sd">                If True, sets the minimum non-zero value to zero. Defaults to False.</span>
<span class="sd">            normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the extracted and processed spectral band.</span>
<span class="sd">                Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the specified band name is not found in the spyndex library.</span>
<span class="sd">            NotImplementedError: If a selection method other than &quot;center&quot; is specified.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The spyndex library is used to map band names to wavelength ranges.</span>
<span class="sd">            - Currently, only the &quot;center&quot; selection method is implemented, which chooses</span>
<span class="sd">            the central wavelength within the specified range.</span>
<span class="sd">            - Processing steps are applied in the order: normalization, cutoff, masking.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(200, 100, 100), wavelengths=np.linspace(400, 2500, 200))</span>
<span class="sd">            &gt;&gt;&gt; red_band = hsi_image.extract_band_by_name(&quot;Red&quot;)</span>
<span class="sd">            &gt;&gt;&gt; red_band.shape</span>
<span class="sd">            torch.Size([100, 100])</span>

<span class="sd">            &gt;&gt;&gt; # Extract NIR band without normalization or masking</span>
<span class="sd">            &gt;&gt;&gt; nir_band = hsi_image.extract_band_by_name(&quot;NIR&quot;, apply_mask=False, normalize=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_info</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band name &#39;</span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">&#39; not found in the spyndex library&quot;</span><span class="p">)</span>

        <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">band_info</span><span class="o">.</span><span class="n">max_wavelength</span>
        <span class="n">selected_wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">selection_method</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_central_slice_from_band</span><span class="p">(</span>
                <span class="n">selected_wavelengths</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Selection method &#39;</span><span class="si">{</span><span class="n">selection_method</span><span class="si">}</span><span class="s2">&#39; is not supported. Only &#39;center&#39; is currently available.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the hsi data to the target orientation.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_orientation (tuple[str, str, str], list[str], str): The target orientation for the hsi data.</span>
<span class="sd">                This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">            inplace (bool, optional): Whether to modify the hsi data in place or return a new object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated HSI object with the new orientation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_orientation</span> <span class="o">=</span> <span class="n">validate_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">target_orientation</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image</span>

        <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

        <span class="c1"># permute the image</span>
        <span class="n">image</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="c1"># permute the binary mask</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="n">image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">target_orientation</span>

        <span class="k">return</span> <span class="n">image</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.hsi.HSI.spatial_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spatial_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a 2D spatial representation of the binary mask.</p>
<p>This property extracts a single 2D slice from the 3D binary mask, assuming that
the mask is identical across all spectral bands. It handles different data
orientations by first ensuring the spectral dimension is the last dimension
before extracting the 2D spatial mask.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A 2D tensor representing the spatial binary mask.
The shape will be (H, W) where H is height and W is width of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <ul>
<li>This assumes that the binary mask is consistent across all spectral bands.</li>
<li>The returned mask is always 2D, regardless of the original data orientation.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># If self.binary_mask has shape (100, 100, 5) with spectral_axis=2:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spatial_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">If</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="n">has</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">with</span> <span class="n">spectral_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spatial_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
</code></pre></div>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="src.meteors.hsi.HSI.spectral_axis" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spectral_axis</span><span class="p">:</span> <span class="nb">int</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the index of the spectral (wavelength) axis based on the current data orientation.</p>
<p>In hyperspectral imaging, the spectral axis represents the dimension along which
different spectral bands or wavelengths are arranged. This property dynamically
determines the index of this axis based on the current orientation of the data.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>int</code></td>            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The index of the spectral axis in the current data structure.
- 0 for 'CHW' or 'CWH' orientations (Channel/Wavelength first)
- 2 for 'HWC' or 'WHC' orientations (Channel/Wavelength last)
- 1 for 'HCW' or 'WCH' orientations (Channel/Wavelength in the middle)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <p>The orientation is typically represented as a string where:
- 'C' represents the spectral/wavelength dimension
- 'H' represents the height (rows) of the image
- 'W' represents the width (columns) of the image</p>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="s2">&quot;CHW&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spectral_axis</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="s2">&quot;HWC&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spectral_axis</span>
<span class="go">2</span>
</code></pre></div>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="src.meteors.hsi.HSI.change_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Changes the orientation of the hsi data to the target orientation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>target_orientation</code></td>
            <td>
                  <code>(tuple[str, str, str], list[str], str)</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The target orientation for the hsi data.
This should be a tuple of three one-letter strings in any order: "C", "H", "W".</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>inplace</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to modify the hsi data in place or return a new object.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated HSI object with the new orientation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the target orientation is not a valid tuple of three one-letter strings.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the hsi data to the target orientation.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_orientation (tuple[str, str, str], list[str], str): The target orientation for the hsi data.</span>
<span class="sd">            This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">        inplace (bool, optional): Whether to modify the hsi data in place or return a new object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated HSI object with the new orientation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_orientation</span> <span class="o">=</span> <span class="n">validate_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">target_orientation</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">image</span>

    <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

    <span class="c1"># permute the image</span>
    <span class="n">image</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="c1"># permute the binary mask</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">image</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="n">image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">target_orientation</span>

    <span class="k">return</span> <span class="n">image</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.hsi.HSI.extract_band_by_name" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">extract_band_by_name</span><span class="p">(</span><span class="n">band_name</span><span class="p">,</span> <span class="n">selection_method</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Extracts a single spectral band from the hyperspectral image based on a standardized band name.</p>
<p>This method uses the spyndex library to map standardized band names to wavelength ranges,
then extracts the corresponding band from the hyperspectral data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>band_name</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The standardized name of the band to extract (e.g., "Red", "NIR", "SWIR1").</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>selection_method</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method to use for selecting the band within the wavelength range.
Currently, only "center" is supported, which selects the central wavelength.
Defaults to "center".</p>
              </div>
            </td>
            <td>
                  <code>&#39;center&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>apply_mask</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the extracted band.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>apply_min_cutoff</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply a minimum intensity cutoff after normalization.
If True, sets the minimum non-zero value to zero. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>normalize</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to normalize the band values to the [0, 1] range.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A 2D tensor representing the extracted and processed spectral band.
Shape will be (H, W), where H is height and W is width of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the specified band name is not found in the spyndex library.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>NotImplementedError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a selection method other than "center" is specified.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The spyndex library is used to map band names to wavelength ranges.</li>
<li>Currently, only the "center" selection method is implemented, which chooses
the central wavelength within the specified range.</li>
<li>Processing steps are applied in the order: normalization, cutoff, masking.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">2500</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red_band</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span><span class="s2">&quot;Red&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red_band</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Extract NIR band without normalization or masking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nir_band</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span><span class="s2">&quot;NIR&quot;</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">extract_band_by_name</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">selection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
    <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extracts a single spectral band from the hyperspectral image based on a standardized band name.</span>

<span class="sd">    This method uses the spyndex library to map standardized band names to wavelength ranges,</span>
<span class="sd">    then extracts the corresponding band from the hyperspectral data.</span>

<span class="sd">    Args:</span>
<span class="sd">        band_name (str): The standardized name of the band to extract (e.g., &quot;Red&quot;, &quot;NIR&quot;, &quot;SWIR1&quot;).</span>
<span class="sd">        selection_method (str, optional): The method to use for selecting the band within the wavelength range.</span>
<span class="sd">            Currently, only &quot;center&quot; is supported, which selects the central wavelength.</span>
<span class="sd">            Defaults to &quot;center&quot;.</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff after normalization.</span>
<span class="sd">            If True, sets the minimum non-zero value to zero. Defaults to False.</span>
<span class="sd">        normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A 2D tensor representing the extracted and processed spectral band.</span>
<span class="sd">            Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the specified band name is not found in the spyndex library.</span>
<span class="sd">        NotImplementedError: If a selection method other than &quot;center&quot; is specified.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The spyndex library is used to map band names to wavelength ranges.</span>
<span class="sd">        - Currently, only the &quot;center&quot; selection method is implemented, which chooses</span>
<span class="sd">        the central wavelength within the specified range.</span>
<span class="sd">        - Processing steps are applied in the order: normalization, cutoff, masking.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(200, 100, 100), wavelengths=np.linspace(400, 2500, 200))</span>
<span class="sd">        &gt;&gt;&gt; red_band = hsi_image.extract_band_by_name(&quot;Red&quot;)</span>
<span class="sd">        &gt;&gt;&gt; red_band.shape</span>
<span class="sd">        torch.Size([100, 100])</span>

<span class="sd">        &gt;&gt;&gt; # Extract NIR band without normalization or masking</span>
<span class="sd">        &gt;&gt;&gt; nir_band = hsi_image.extract_band_by_name(&quot;NIR&quot;, apply_mask=False, normalize=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">band_info</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">band_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band name &#39;</span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">&#39; not found in the spyndex library&quot;</span><span class="p">)</span>

    <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">band_info</span><span class="o">.</span><span class="n">max_wavelength</span>
    <span class="n">selected_wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">selection_method</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_central_slice_from_band</span><span class="p">(</span>
            <span class="n">selected_wavelengths</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Selection method &#39;</span><span class="si">{</span><span class="n">selection_method</span><span class="si">}</span><span class="s2">&#39; is not supported. Only &#39;center&#39; is currently available.&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.hsi.HSI.get_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the hyperspectral image data with optional masking applied.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>apply_mask</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the image.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Returns:
    torch.Tensor: The hyperspectral image data.</p>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>If apply_mask is True, the binary mask will be applied to the image based on the <code>binary_mask</code> attribute.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 100, 100])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 100, 100])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the hyperspectral image data with optional masking applied.</span>

<span class="sd">    Args:</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The hyperspectral image data.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If apply_mask is True, the binary mask will be applied to the image based on the `binary_mask` attribute.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">        &gt;&gt;&gt; image = hsi_image.get_image()</span>
<span class="sd">        &gt;&gt;&gt; image.shape</span>
<span class="sd">        torch.Size([10, 100, 100])</span>
<span class="sd">        &gt;&gt;&gt; image = hsi_image.get_image(apply_mask=False)</span>
<span class="sd">        &gt;&gt;&gt; image.shape</span>
<span class="sd">        torch.Size([10, 100, 100])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">apply_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.hsi.HSI.get_rgb_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Extracts an RGB representation from the hyperspectral image data.</p>
<p>This method creates a 3-channel RGB image by selecting appropriate bands
corresponding to red, green, and blue wavelengths from the hyperspectral data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>apply_mask</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the image.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>apply_min_cutoff</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply a minimum intensity
cutoff to the image. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>output_channel_axis</code></td>
            <td>
                  <code>int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axis where the RGB channels
should be placed in the output tensor. If None, uses the current spectral
axis of the hyperspectral data. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The RGB representation of the hyperspectral image.
Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on
the specified output_channel_axis, where H is height and W is width.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</li>
<li>Each band is normalized independently before combining into the RGB image.</li>
<li>If apply_mask is True, masked areas will be set to zero in the output.</li>
<li>If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100, 3])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">output_channel_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([3, 100, 100])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100, 3])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_rgb_image</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extracts an RGB representation from the hyperspectral image data.</span>

<span class="sd">    This method creates a 3-channel RGB image by selecting appropriate bands</span>
<span class="sd">    corresponding to red, green, and blue wavelengths from the hyperspectral data.</span>

<span class="sd">    Args:</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        apply_min_cutoff (bool, optional): Whether to apply a minimum intensity</span>
<span class="sd">            cutoff to the image. Defaults to False.</span>
<span class="sd">        output_channel_axis (int | None, optional): The axis where the RGB channels</span>
<span class="sd">            should be placed in the output tensor. If None, uses the current spectral</span>
<span class="sd">            axis of the hyperspectral data. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The RGB representation of the hyperspectral image.</span>
<span class="sd">            Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on</span>
<span class="sd">            the specified output_channel_axis, where H is height and W is width.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</span>
<span class="sd">        - Each band is normalized independently before combining into the RGB image.</span>
<span class="sd">        - If apply_mask is True, masked areas will be set to zero in the output.</span>
<span class="sd">        - If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image()</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([100, 100, 3])</span>

<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(output_channel_axis=0)</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([3, 100, 100])</span>

<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(apply_mask=False, apply_min_cutoff=True)</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([100, 100, 3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_channel_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>

    <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span>
                <span class="n">band</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">rgb_img</span>
        <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>
        <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rgb_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">)</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.hsi.HSI.to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Moves the image and binary mask (if available) to the specified device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str or <span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to move the image and binary mask to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated Image object.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an HSI object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Move the image to cpu</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Move the image to cuda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;, index=0)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Moves the image and binary mask (if available) to the specified device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str or torch.device): The device to move the image and binary mask to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated Image object.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Create an HSI object</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 10, 10), wavelengths=np.arange(10))</span>
<span class="sd">        &gt;&gt;&gt; # Move the image to cpu</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cpu&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Move the image to cuda</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cuda&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">        device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.hsi.HSI.validate_image_data" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_image_data</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Validates the image data by checking the shape of the wavelengths, image, and spectral_axis.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The instance of the class.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">validate_image_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates the image data by checking the shape of the wavelengths, image, and spectral_axis.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The instance of the class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="src.meteors.hsi.ensure_image_tensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">ensure_image_tensor</span><span class="p">(</span><span class="n">image</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Ensures the input image is a PyTorch tensor, converting it if necessary.</p>
<p>This function validates that the input is either a numpy array or a PyTorch tensor,
and converts numpy arrays to PyTorch tensors. If the input is already a PyTorch tensor,
it is returned unchanged.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>image</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input image to be converted/validated.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The image as a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the image is neither a numpy array nor a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ensure_image_tensor</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensures the input image is a PyTorch tensor, converting it if necessary.</span>

<span class="sd">    This function validates that the input is either a numpy array or a PyTorch tensor,</span>
<span class="sd">    and converts numpy arrays to PyTorch tensors. If the input is already a PyTorch tensor,</span>
<span class="sd">    it is returned unchanged.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (np.ndarray | torch.Tensor): The input image to be converted/validated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The image as a PyTorch tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the image is neither a numpy array nor a PyTorch tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Image must be either a numpy array or a PyTorch tensor&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.hsi.ensure_wavelengths_tensor" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">ensure_wavelengths_tensor</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Converts the input wavelengths to a PyTorch tensor.</p>
<p>This function takes wavelength data in various formats and ensures it is converted
to a PyTorch tensor. It accepts PyTorch tensors, NumPy arrays, lists, or tuples of
numeric values.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>wavelengths</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | <span title="numpy.ndarray">ndarray</span> | list[int | float] | tuple[int | float]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input wavelengths in any of the supported formats.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The wavelengths as a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input is not a PyTorch tensor, NumPy array, list, or tuple.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the wavelengths cannot be converted to a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ensure_wavelengths_tensor</span><span class="p">(</span>
    <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts the input wavelengths to a PyTorch tensor.</span>

<span class="sd">    This function takes wavelength data in various formats and ensures it is converted</span>
<span class="sd">    to a PyTorch tensor. It accepts PyTorch tensors, NumPy arrays, lists, or tuples of</span>
<span class="sd">    numeric values.</span>

<span class="sd">    Args:</span>
<span class="sd">        wavelengths (torch.Tensor | np.ndarray | list[int | float] | tuple[int | float]):</span>
<span class="sd">            The input wavelengths in any of the supported formats.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The wavelengths as a PyTorch tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input is not a PyTorch tensor, NumPy array, list, or tuple.</span>
<span class="sd">        ValueError: If the wavelengths cannot be converted to a PyTorch tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wavelengths must be a PyTorch tensor, NumPy array, list, or tuple of numeric values&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to convert wavelengths to a PyTorch tensor: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">wavelengths</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.hsi.get_channel_axis" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_channel_axis</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns the index of the channel axis in the orientation list.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>int</code></td>            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The index of the band axis.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_channel_axis</span><span class="p">(</span><span class="n">orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the index of the channel axis in the orientation list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The index of the band axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.hsi.process_and_validate_binary_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">process_and_validate_binary_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Processes and validates a binary mask, ensuring it's in the correct format and shape.</p>
<p>This function handles various input types for binary masks, including None (creates a mask of ones),
'artificial' (creates a mask based on the first channel of the image), numpy arrays, and PyTorch tensors.
It ensures the output is a PyTorch tensor of the correct shape and type.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>mask</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | None | str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input binary mask or mask specification.
- If None: Creates a mask of ones with the same shape as the image.
- If 'artificial': Creates a mask based on the first channel of the image.
- If numpy array or PyTorch tensor: Converts to a boolean PyTorch tensor.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>info</code></td>
            <td>
                  <code><span title="pydantic.ValidationInfo">ValidationInfo</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dataclass containing additional required information:
- 'image': The reference image (PyTorch tensor) for shape and device.
- 'orientation': The orientation of the image data.
- 'device': The PyTorch device to use.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A boolean PyTorch tensor representing the validated and processed binary mask.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input mask is invalid or if required information is missing from info.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the resulting binary mask doesn't match the shape of the reference image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">process_and_validate_binary_mask</span><span class="p">(</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">info</span><span class="p">:</span> <span class="n">ValidationInfo</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Processes and validates a binary mask, ensuring it&#39;s in the correct format and shape.</span>

<span class="sd">    This function handles various input types for binary masks, including None (creates a mask of ones),</span>
<span class="sd">    &#39;artificial&#39; (creates a mask based on the first channel of the image), numpy arrays, and PyTorch tensors.</span>
<span class="sd">    It ensures the output is a PyTorch tensor of the correct shape and type.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (np.ndarray | torch.Tensor | None | str): The input binary mask or mask specification.</span>
<span class="sd">            - If None: Creates a mask of ones with the same shape as the image.</span>
<span class="sd">            - If &#39;artificial&#39;: Creates a mask based on the first channel of the image.</span>
<span class="sd">            - If numpy array or PyTorch tensor: Converts to a boolean PyTorch tensor.</span>
<span class="sd">        info (ValidationInfo): A dataclass containing additional required information:</span>
<span class="sd">            - &#39;image&#39;: The reference image (PyTorch tensor) for shape and device.</span>
<span class="sd">            - &#39;orientation&#39;: The orientation of the image data.</span>
<span class="sd">            - &#39;device&#39;: The PyTorch device to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A boolean PyTorch tensor representing the validated and processed binary mask.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input mask is invalid or if required information is missing from info.</span>
<span class="sd">        ValueError: If the resulting binary mask doesn&#39;t match the shape of the reference image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Binary mask must be None, a PyTorch tensor, a numpy array, or the string &#39;artificial&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;image&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span> <span class="ow">or</span> <span class="s2">&quot;orientation&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span> <span class="ow">or</span> <span class="s2">&quot;device&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing required information in ValidationInfo&quot;</span><span class="p">)</span>

    <span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
    <span class="n">spectral_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">get_channel_axis</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">])</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;device&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="o">==</span> <span class="s2">&quot;artificial&quot;</span><span class="p">:</span>
            <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">))</span><span class="o">.</span><span class="n">bool</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span>
                <span class="n">binary_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">spectral_axis</span><span class="p">),</span>
                <span class="n">repeats</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">spectral_axis</span><span class="p">],</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">spectral_axis</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;String mask specification must be &#39;artificial&#39;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Binary mask shape </span><span class="si">{</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match image shape </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">binary_mask</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.hsi.resolve_inference_device" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">resolve_inference_device</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Resolves and returns the device to be used for inference.</p>
<p>This function determines the appropriate PyTorch device for inference based on the input
parameters and available information. It handles three scenarios:
1. If a specific device is provided, it validates and returns it.
2. If no device is specified (None), it uses the device of the input image.
3. If a string is provided, it attempts to convert it to a torch.device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str | <span title="torch.device">device</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The desired device for inference.
If None, the device of the input image will be used.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>info</code></td>
            <td>
                  <code><span title="pydantic.ValidationInfo">ValidationInfo</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An object containing additional validation information,
including the input image data.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.device: The resolved PyTorch device for inference.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If no device is specified and the image is not present in the info data,
or if the provided device string is invalid.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the provided device is neither None, a string, nor a torch.device.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">resolve_inference_device</span><span class="p">(</span><span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="p">:</span> <span class="n">ValidationInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Resolves and returns the device to be used for inference.</span>

<span class="sd">    This function determines the appropriate PyTorch device for inference based on the input</span>
<span class="sd">    parameters and available information. It handles three scenarios:</span>
<span class="sd">    1. If a specific device is provided, it validates and returns it.</span>
<span class="sd">    2. If no device is specified (None), it uses the device of the input image.</span>
<span class="sd">    3. If a string is provided, it attempts to convert it to a torch.device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str | torch.device | None): The desired device for inference.</span>
<span class="sd">            If None, the device of the input image will be used.</span>
<span class="sd">        info (ValidationInfo): An object containing additional validation information,</span>
<span class="sd">            including the input image data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.device: The resolved PyTorch device for inference.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If no device is specified and the image is not present in the info data,</span>
<span class="sd">            or if the provided device string is invalid.</span>
<span class="sd">        TypeError: If the provided device is neither None, a string, nor a torch.device.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;image&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image is not present in the data, INTERNAL ERROR&quot;</span><span class="p">)</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">device</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> is not valid&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Device should be a string or torch device&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Device for inference: </span><span class="si">{</span><span class="n">device</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">device</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.hsi.validate_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_orientation</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates the orientation tuple.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>value</code></td>
            <td>
                  <code>tuple[str, str, str] | list[str] | str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The orientation value to be validated. It should be a tuple of three one-letter strings.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[str, str, str]: The validated orientation value.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the value is not a tuple of three one-letter strings
or if it does not contain 'W', 'H', and 'C' in any order.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_orientation</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates the orientation tuple.</span>

<span class="sd">    Args:</span>
<span class="sd">        value (tuple[str, str, str] | list[str] | str):</span>
<span class="sd">            The orientation value to be validated. It should be a tuple of three one-letter strings.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[str, str, str]: The validated orientation value.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the value is not a tuple of three one-letter strings</span>
<span class="sd">            or if it does not contain &#39;W&#39;, &#39;H&#39;, and &#39;C&#39; in any order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="p">{</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Orientation must be a tuple of &#39;H&#39;, &#39;W&#39;, and &#39;C&#39; in any order.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>  <span class="c1"># type: ignore</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="src.meteors.hsi.validate_shapes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_shapes</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">spectral_axis</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Validates that the length of the wavelengths matches the number of channels in the image tensor.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>wavelengths</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of wavelengths.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>image</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Image tensor.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>spectral_axis</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Index of the band axis in the image tensor.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the length of wavelengths does not correspond to the number of channels in the image tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">validate_shapes</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">spectral_axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates that the length of the wavelengths matches the number of channels in the image tensor.</span>

<span class="sd">    Args:</span>
<span class="sd">        wavelengths (torch.Tensor): Array of wavelengths.</span>
<span class="sd">        image (torch.Tensor): Image tensor.</span>
<span class="sd">        spectral_axis (int): Index of the band axis in the image tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the length of wavelengths does not correspond to the number of channels in the image tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wavelengths</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">spectral_axis</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of wavelengths must match the number of channels in the image.&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../assets/javascripts/bundle.56dfad97.min.js"></script>
      
    
  </body>
</html>